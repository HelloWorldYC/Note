{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{359:function(t,s,a){t.exports=a.p+\"assets/img/其他的运算符.2922cda9.png\"},360:function(t,s,a){t.exports=a.p+\"assets/img/java内存.e3f0abab.png\"},361:function(t,s,a){t.exports=a.p+\"assets/img/数组内存图.2d93a684.png\"},362:function(t,s,a){t.exports=a.p+\"assets/img/两个数组指向同一个空间的内存图.155182d3.png\"},363:function(t,s,a){t.exports=a.p+\"assets/img/从内存角度解释基本数据类型和引用数据类型.69e2258c.png\"},364:function(t,s,a){t.exports=a.p+\"assets/img/方法调用的基本内存原理（1）.f71f8758.png\"},365:function(t,s,a){t.exports=a.p+\"assets/img/方法调用的基本内存原理（2）.b38f2d78.png\"},366:function(t,s,a){t.exports=a.p+\"assets/img/基本数据类型的内存原理.7c0bdf3a.png\"},367:function(t,s,a){t.exports=a.p+\"assets/img/引用数据类型的内存原理.bf02b2db.png\"},368:function(t,s,a){t.exports=a.p+\"assets/img/一个对象的内存图.ac9a495a.png\"},369:function(t,s,a){t.exports=a.p+\"assets/img/两个对象的内存图.8bafbf54.png\"},370:function(t,s,a){t.exports=a.p+\"assets/img/两个引用指向同一个对象.c6cb967f.png\"},371:function(t,s,a){t.exports=a.p+\"assets/img/this的内存原理（1）.b371cf3a.png\"},372:function(t,s,a){t.exports=a.p+\"assets/img/this的内存原理（2）.5c2ba3d8.png\"},373:function(t,s,a){t.exports=a.p+\"assets/img/成员变量和局部变量的区别.ecdeff42.png\"},374:function(t,s,a){t.exports=a.p+\"assets/img/字符串拼接底层原理—没有变量参与时.8c8523d1.png\"},375:function(t,s,a){t.exports=a.p+\"assets/img/字符串拼接底层原理—等号右边有变量参与时.e1987069.png\"},376:function(t,s,a){t.exports=a.p+\"assets/img/StringBuilder存储原理.0ac54a22.png\"},377:function(t,s,a){t.exports=a.p+\"assets/img/字符串拼接例子.357315c9.png\"},378:function(t,s,a){t.exports=a.p+\"assets/img/字符串拼接例子二.2d9fe6c1.png\"},379:function(t,s,a){t.exports=a.p+\"assets/img/StringBuilder默认存储机制.df3a308e.png\"},380:function(t,s,a){t.exports=a.p+\"assets/img/static内存图.cead9c3c.png\"},381:function(t,s,a){t.exports=a.p+\"assets/img/继承的内存图.08524115.png\"},382:function(t,s,a){t.exports=a.p+\"assets/img/成员方法是否可以被继承.5d50e92f.png\"},383:function(t,s,a){t.exports=a.p+\"assets/img/成员方法被继承内存图.e54c3c59.png\"},384:function(t,s,a){t.exports=a.p+\"assets/img/方法重写的本质.9485dcb8.png\"},385:function(t,s,a){t.exports=a.p+\"assets/img/正则表达式非捕获分组.4d67d228.png\"},386:function(t,s,a){t.exports=a.p+\"assets/img/单列集合.73f83d50.png\"},387:function(t,s,a){t.exports=a.p+\"assets/img/Collection集合常用方法.690326fe.png\"},388:function(t,s,a){t.exports=a.p+\"assets/img/迭代器遍历.bd807705.png\"},389:function(t,s,a){t.exports=a.p+\"assets/img/List集合特有方法.7c9568fd.png\"},390:function(t,s,a){t.exports=a.p+\"assets/img/ArrayList集合底层原理.483dbda2.png\"},391:function(t,s,a){t.exports=a.p+\"assets/img/ArrayList第一次扩容的情况.3c69de1a.png\"},392:function(t,s,a){t.exports=a.p+\"assets/img/ArrayList后续扩容的情况.00524258.png\"},393:function(t,s,a){t.exports=a.p+\"assets/img/LinkedList集合特有API.3e61f5e4.png\"},394:function(t,s,a){t.exports=a.p+\"assets/img/LinkedList底层源码.b2fd0177.png\"},395:function(t,s,a){t.exports=a.p+\"assets/img/迭代器底层源码分析.21e23473.png\"},396:function(t,s,a){t.exports=a.p+\"assets/img/常见的数据结构.68a695ba.png\"},397:function(t,s,a){t.exports=a.p+\"assets/img/链表中结点结构.44b40933.png\"},398:function(t,s,a){t.exports=a.p+\"assets/img/单向链表和双向链表.55ebe27d.png\"},399:function(t,s,a){t.exports=a.p+\"assets/img/树节点内部组成.fb9c7223.png\"},602:function(t,s,a){\"use strict\";a.r(s);var n=a(18),r=Object(n.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[n(\"h2\",{attrs:{id:\"注意-详细笔记看黑马程序员阿玮的课程笔记\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#注意-详细笔记看黑马程序员阿玮的课程笔记\"}},[t._v(\"#\")]),t._v(\" 注意：详细笔记看黑马程序员阿玮的课程笔记\")]),t._v(\" \"),n(\"h3\",{attrs:{id:\"t-制表符\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#t-制表符\"}},[t._v(\"#\")]),t._v(\" \\\\t 制表符\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"作用：在打印的时候，把前面字符串的长度补齐到8，或者8的整数倍。最少补1个空格，最多补8个空格。\")])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"null\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#null\"}},[t._v(\"#\")]),t._v(\" null\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"在打印时不能直接打印，要以字符串的形式打印。\")])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"任意进制转十进制\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#任意进制转十进制\"}},[t._v(\"#\")]),t._v(\" 任意进制转十进制\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"公式：系数*基数的权次幂 相加\\n\"),n(\"ul\",[n(\"li\",[t._v(\"系数：当前的进制数\")]),t._v(\" \"),n(\"li\",[t._v(\"基数：当前进制数\")]),t._v(\" \"),n(\"li\",[t._v(\"权：从右往左，依次为 0 1 2 3 4 5 …\")])])])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"十进制转任意进制\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#十进制转任意进制\"}},[t._v(\"#\")]),t._v(\" 十进制转任意进制\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"除基取余法\\n\"),n(\"ul\",[n(\"li\",[t._v(\"不断地除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着拼起来即可。\")])])])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"float的数值范围比long大\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#float的数值范围比long大\"}},[t._v(\"#\")]),t._v(\" float的数值范围比long大\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"原因：float类型数字在计算机中用4个字节存储。遵循IEEE-754格式标准：         一个浮点数有2部分组成：底数m和指数e  底数部分 使用二进制数来表示此浮点数的实际值 指数部分 占用8bit的二进制数，可表示数值范围为0-255  但是指数可正可负，所以，IEEE规定，此处算出的次方必须减去127才是真正的指数。         所以，float类型的指数可从-126到128  底数部分实际是占用24bit的一个值，但是最高位始终为1，所以，最高位省去不存储，在存储中占23bit         科学计数法。  格式： SEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM S表示浮点数正负     E指数加上127后的值得二进制数据 M底数  举例： 17.625在内存中的存储  首先要把17.625换算成二进制：10001.101          整数部分，除以2，直到商为0，余数反转。         小数部分，乘以2，直到乘位0，进位顺序取。  在将10001.101右移，直到小数点前只剩1位：         1.0001101 * 2^4 因为右移动了四位  这个时候，我们的底数和指数就出来了 底数：因为小数点前必为1，所以IEEE规定只记录小数点后的就好。所以，此处的底数为：0001101 指数：实际为4，必须加上127(转出的时候，减去127)，所以为131。也就是10000011 符号部分是整数，所以是0 综上所述，17.625在内存中的存储格式是： 01000001 10001101 00000000 00000000\")])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"原码\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#原码\"}},[t._v(\"#\")]),t._v(\" 原码\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"原码：十进制数据的二进制表现形式，最左边是符号位，0为正，1为负。\")])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"反码\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#反码\"}},[t._v(\"#\")]),t._v(\" 反码\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"目的：为了解决原码不能计算负数的问题而出现的。\")]),t._v(\" \"),n(\"li\",[t._v(\"计算规则：正数的补码反码是其本身，负数的反码是符号位保持不变，其余位取反，0变1，1变0。\")]),t._v(\" \"),n(\"li\",[t._v(\"弊端：负数运算时，如果结果不跨0，没有任何问题，但是如果结果跨0，跟实际结果会有1的偏差。\")])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"补码\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#补码\"}},[t._v(\"#\")]),t._v(\" 补码\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"目的：为了解决负数计算时跨0的问题而出现的。\")]),t._v(\" \"),n(\"li\",[t._v(\"计算规则：正数的补码是其本身，负数的补码是在其反码的基础上+1。另外，补码还能多记录一个特殊的值-128，该数据在1个字节下，没有原码和反码（因此一个字节的取值范围为-128~127）。\")]),t._v(\" \"),n(\"li\",[t._v(\"注意点：计算机中的存储和计算都是以补码的形式进行的。因为CPU只会做加法运算，数的补码形式可以用加法实现减法运算。\")])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"其他运算符\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#其他运算符\"}},[t._v(\"#\")]),t._v(\" 其他运算符\")]),t._v(\" \"),n(\"div\",{attrs:{align:\"center\"}},[n(\"img\",{attrs:{src:a(359),width:\"100%\"}})]),t._v(\" \"),n(\"h3\",{attrs:{id:\"for-和-while-的对比\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#for-和-while-的对比\"}},[t._v(\"#\")]),t._v(\" for 和 while 的对比\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"相同点：运行规则都是一样的\")]),t._v(\" \"),n(\"li\",[t._v(\"区别：\\n\"),n(\"ul\",[n(\"li\",[t._v(\"for循环中，控制循环的变量，因为归属于for循环的语法结构中，在for循环结束后，就不能再次被访问到了。\")]),t._v(\" \"),n(\"li\",[t._v(\"while循环中，控制循环的变量，对于while循环来说不归属其语法结构中，在while循环结束后，该变量还可以继续使用。\")])])]),t._v(\" \"),n(\"li\",[t._v(\"注意：循环的条件判断语句中条件不能随循环而变，一定要是确定的。\")])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"return-和-break-关键字的区别\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#return-和-break-关键字的区别\"}},[t._v(\"#\")]),t._v(\" return 和 break 关键字的区别\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"return：跟循环没有什么关系，跟方法有关，表示 1 结束方法 2 返回结果。如果方法执行到了return，那么整个方法全部结束，里面的循环也会随之结束了。\")]),t._v(\" \"),n(\"li\",[t._v(\"break：跟方法没有什么关系，表示结束循环或 switch。\")])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"java-内存分配\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#java-内存分配\"}},[t._v(\"#\")]),t._v(\" java 内存分配\")]),t._v(\" \"),n(\"div\",{attrs:{align:\"center\"}},[n(\"img\",{attrs:{src:a(360),width:\"100%\"}})]),t._v(\" \"),n(\"h3\",{attrs:{id:\"数组内存图\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#数组内存图\"}},[t._v(\"#\")]),t._v(\" 数组内存图\")]),t._v(\" \"),n(\"div\",{attrs:{align:\"center\"}},[n(\"img\",{attrs:{src:a(361),width:\"100%\"}})]),t._v(\" \"),n(\"p\",[t._v(\"总结：\")]),t._v(\" \"),n(\"ol\",[n(\"li\",[t._v(\"只要是 new 出来的一定是在堆里面开辟了一个小空间。\")]),t._v(\" \"),n(\"li\",[t._v(\"如果 new 了多次，那么在堆里面有多个小空间，每个小空间中都有各自的数据。\")])]),t._v(\" \"),n(\"div\",{attrs:{align:\"center\"}},[n(\"img\",{attrs:{src:a(362),width:\"100%\"}})]),t._v(\" \"),n(\"p\",[t._v(\"总结：当两个数组指向同一个小空间时，其中一个数组对小空间中的值发生了改变，那么其他数组再次访问的时候都是修改之后的结果了。\")]),t._v(\" \"),n(\"h3\",{attrs:{id:\"基本数据类型和引用数据类型-从内存角度解释\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#基本数据类型和引用数据类型-从内存角度解释\"}},[t._v(\"#\")]),t._v(\" 基本数据类型和引用数据类型（从内存角度解释）\")]),t._v(\" \"),n(\"div\",{attrs:{align:\"center\"}},[n(\"img\",{attrs:{src:a(363),width:\"100%\"}})]),t._v(\" \"),n(\"h3\",{attrs:{id:\"方法的内存\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#方法的内存\"}},[t._v(\"#\")]),t._v(\" 方法的内存\")]),t._v(\" \"),n(\"ol\",[n(\"li\",[t._v(\"方法调用的基本内存原理\\n\"),n(\"div\",{attrs:{align:\"center\"}},[n(\"img\",{attrs:{src:a(364),width:\"100%\"}})]),n(\"br\"),t._v(\" \"),n(\"div\",{attrs:{align:\"center\"}},[n(\"img\",{attrs:{src:a(365),width:\"100%\"}})])])]),t._v(\" \"),n(\"p\",[n(\"strong\",[t._v(\"注意：\")]),t._v(\"：栈的特点是先进后出。\")]),t._v(\" \"),n(\"ol\",{attrs:{start:\"2\"}},[n(\"li\",[n(\"p\",[t._v(\"方法传递基本数据类型的内存原理\\n\")]),n(\"div\",{attrs:{align:\"center\"}},[n(\"img\",{attrs:{src:a(366),width:\"100%\"}})]),n(\"br\"),t._v(\"\\n传递基本数据类型时，传递的是真实的数据，形参的改变，不影响实际参数的值。\"),n(\"p\")]),t._v(\" \"),n(\"li\",[n(\"p\",[t._v(\"方法传递引用数据类型的内存原理\\n\")]),n(\"div\",{attrs:{align:\"center\"}},[n(\"img\",{attrs:{src:a(367),width:\"100%\"}})]),n(\"br\"),t._v(\"\\n传递引用数据类型时，传递的是地址值，形参的改变，影响实际参数的值。\"),n(\"p\")])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"定义类的补充注意事项\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#定义类的补充注意事项\"}},[t._v(\"#\")]),t._v(\" 定义类的补充注意事项\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[n(\"p\",[t._v(\"用来描述一类事物的类，专业叫做：\"),n(\"strong\",[t._v(\"Javabean类\")]),t._v(\"。\"),n(\"br\"),t._v(\"\\n在Javabean类中，是不写main方法的。\")])]),t._v(\" \"),n(\"li\",[n(\"p\",[t._v(\"在之前，编写有main方法的类，叫做 \"),n(\"strong\",[t._v(\"测试类\")]),t._v(\"。\"),n(\"br\"),t._v(\"\\n我们可以在测试类中创建javabean类的对象并进行赋值调用。\")])]),t._v(\" \"),n(\"li\",[n(\"p\",[t._v(\"类名首字母建议大写，需要见名知意，驼峰模式。\")])]),t._v(\" \"),n(\"li\",[n(\"p\",[t._v(\"一个java文件中可以定义多个class类，且只能一个类是public修饰，而且public修饰的类名必须成为代码文件名。\"),n(\"strong\",[t._v(\"实际开发中建议还是一个文件定义一个class类\")]),t._v(\"。\")])]),t._v(\" \"),n(\"li\",[n(\"p\",[t._v(\"成员变量的完整定义格式是：\"),n(\"strong\",[n(\"code\",[t._v(\"修饰符 数据类型 变量名称 = 初始化值;\")])]),t._v(\" 一般无需指定初始化值，存在默认值。\")])])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"就近原则\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#就近原则\"}},[t._v(\"#\")]),t._v(\" 就近原则\")]),t._v(\" \"),n(\"div\",{staticClass:\"language-java extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-java\"}},[n(\"code\",[n(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"System\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),t._v(\"out\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"println\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"age\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"System\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),t._v(\"out\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"println\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"this\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),t._v(\"age\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//this的作用：可以区分成员变量和局部变量\")]),t._v(\"\\n\")])])]),n(\"h3\",{attrs:{id:\"构造方法\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#构造方法\"}},[t._v(\"#\")]),t._v(\" 构造方法\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"格式\")])]),t._v(\" \"),n(\"div\",{staticClass:\"language-java extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-java\"}},[n(\"code\",[n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"public\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"class\")]),t._v(\" 类名 \"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n  修饰符 类名\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"参数\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    方法体\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n  \"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\"\\n\")])])]),n(\"ul\",[n(\"li\",[n(\"p\",[t._v(\"特点：\")]),t._v(\" \"),n(\"ol\",[n(\"li\",[t._v(\"方法名与类名相同，大小写也要一致\")]),t._v(\" \"),n(\"li\",[t._v(\"没有返回值类型，连void都没有\")]),t._v(\" \"),n(\"li\",[t._v(\"没有具体的返回值（不能由return带回结果数据）\")])])]),t._v(\" \"),n(\"li\",[n(\"p\",[t._v(\"执行时机\")]),t._v(\" \"),n(\"ol\",[n(\"li\",[t._v(\"创建对象的时候由虚拟机调用，不能手动调用构造方法\")]),t._v(\" \"),n(\"li\",[t._v(\"每创建一次对象，就会调用一次构造方法\")])])])]),t._v(\" \"),n(\"h2\",{attrs:{id:\"对象内存图\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#对象内存图\"}},[t._v(\"#\")]),t._v(\" 对象内存图\")]),t._v(\" \"),n(\"h3\",{attrs:{id:\"一个对象的内存图\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#一个对象的内存图\"}},[t._v(\"#\")]),t._v(\" 一个对象的内存图\")]),t._v(\" \"),n(\"div\",{staticClass:\"language-java extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-java\"}},[n(\"code\",[n(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"Student\")]),t._v(\" s \"),n(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"new\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"Student\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\")])])]),n(\"ol\",[n(\"li\",[t._v(\"加载class文件到方法区\")]),t._v(\" \"),n(\"li\",[t._v(\"申明局部变量\")]),t._v(\" \"),n(\"li\",[t._v(\"在堆内存中开辟一个空间\")]),t._v(\" \"),n(\"li\",[t._v(\"默认初始化\")]),t._v(\" \"),n(\"li\",[t._v(\"显示初始化\")]),t._v(\" \"),n(\"li\",[t._v(\"构造方法初始化\")]),t._v(\" \"),n(\"li\",[t._v(\"将堆内存中的地址值赋值给左边的局部变量\")])]),t._v(\" \"),n(\"div\",{attrs:{align:\"center\"}},[n(\"img\",{attrs:{src:a(368),width:\"100%\"}})]),t._v(\" \"),n(\"h3\",{attrs:{id:\"两个对象的内存图\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#两个对象的内存图\"}},[t._v(\"#\")]),t._v(\" 两个对象的内存图\")]),t._v(\" \"),n(\"div\",{attrs:{align:\"center\"}},[n(\"img\",{attrs:{src:a(369),width:\"100%\"}})]),t._v(\" \"),n(\"h3\",{attrs:{id:\"两个引用指向同一个对象\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#两个引用指向同一个对象\"}},[t._v(\"#\")]),t._v(\" 两个引用指向同一个对象\")]),t._v(\" \"),n(\"div\",{attrs:{align:\"center\"}},[n(\"img\",{attrs:{src:a(370),width:\"100%\"}})]),t._v(\" \"),n(\"h3\",{attrs:{id:\"this的内存原理\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#this的内存原理\"}},[t._v(\"#\")]),t._v(\" this的内存原理\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"this的作用：区分局部变量和成员变量\")]),t._v(\" \"),n(\"li\",[t._v(\"this的本质：所在方法调用者的地址值\\n\"),n(\"div\",{attrs:{align:\"center\"}},[n(\"img\",{attrs:{src:a(371),width:\"100%\"}})]),n(\"br\"),t._v(\" \"),n(\"div\",{attrs:{align:\"center\"}},[n(\"img\",{attrs:{src:a(372),width:\"100%\"}})])])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"成员变量和局部变量的区别\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#成员变量和局部变量的区别\"}},[t._v(\"#\")]),t._v(\" 成员变量和局部变量的区别\")]),t._v(\" \"),n(\"div\",{attrs:{align:\"center\"}},[n(\"img\",{attrs:{src:a(373),width:\"100%\"}})]),t._v(\" \"),n(\"h3\",{attrs:{id:\"键盘录入\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#键盘录入\"}},[t._v(\"#\")]),t._v(\" 键盘录入\")]),t._v(\" \"),n(\"div\",{staticClass:\"language-java extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-java\"}},[n(\"code\",[n(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//第一套体系：遇到空格、制表符、回车就停止接收，这些符号后面的数据就不会接收了\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"nextInt\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"      \"),n(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//接收整数\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"nextDouble\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"   \"),n(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//接收小数\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"next\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"         \"),n(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//接收字符串 \")]),t._v(\"\\n\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//第二套体系：遇到回车才停止\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"nextLine\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"     \"),n(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//接收字符串\")]),t._v(\"\\n\")])])]),n(\"h3\",{attrs:{id:\"stringbuilder-类\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#stringbuilder-类\"}},[t._v(\"#\")]),t._v(\" StringBuilder 类\")]),t._v(\" \"),n(\"p\",[t._v(\"StringBuilder 是 java 已经写好的类，java 在底层对其做了一些特殊处理，打印对象不是地址值而是属性值。\")]),t._v(\" \"),n(\"h2\",{attrs:{id:\"字符串原理\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#字符串原理\"}},[t._v(\"#\")]),t._v(\" 字符串原理\")]),t._v(\" \"),n(\"h3\",{attrs:{id:\"字符串存储的内存原理\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#字符串存储的内存原理\"}},[t._v(\"#\")]),t._v(\" 字符串存储的内存原理\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"直接赋值会复用字符串常量池中的\")]),t._v(\" \"),n(\"li\",[t._v(\"new 出来的不会复用，而是开辟一个新的空间\")])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"号比较的是什么\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#号比较的是什么\"}},[t._v(\"#\")]),t._v(\" ==号比较的是什么\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"基本数据类型比较数据值\")]),t._v(\" \"),n(\"li\",[t._v(\"引用数据类型比较地址值\")])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"字符串拼接的底层原理\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#字符串拼接的底层原理\"}},[t._v(\"#\")]),t._v(\" 字符串拼接的底层原理\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[n(\"p\",[t._v(\"等号右边没有变量参与拼接时\\n\")]),n(\"div\",{attrs:{align:\"center\"}},[n(\"img\",{attrs:{src:a(374),width:\"100%\"}})]),n(\"p\")]),t._v(\" \"),n(\"li\",[n(\"p\",[t._v(\"等号右边有变量参与拼接时(JDK7及JDK7以前)\\n\")]),n(\"div\",{attrs:{align:\"center\"}},[n(\"img\",{attrs:{src:a(375),width:\"100%\"}})]),n(\"p\")])]),t._v(\" \"),n(\"p\",[t._v(\"在JDK8以后进行字符串拼接时，程序先预估需要拼接的字符串的长度创建了一个数组来存储，最后再将数组变为字符串。\"),n(\"br\"),t._v(\"\\n结论：\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"如果没有变量参与，都是字符串直接相加，编译之后就是拼接之后的结果，会复用串池中的字符串\")]),t._v(\" \"),n(\"li\",[t._v(\"如果有变量参与，每一行拼接的代码，都会在内存中创建新的字符串，浪费内存\")])]),t._v(\" \"),n(\"p\",[t._v(\"建议：如果很多字符串变量拼接，不要直接+。在底层会创建多个对象，浪费时间，浪费性能。\")]),t._v(\" \"),n(\"h3\",{attrs:{id:\"stringbuilder-提高效率原理图\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#stringbuilder-提高效率原理图\"}},[t._v(\"#\")]),t._v(\" StringBuilder 提高效率原理图\")]),t._v(\" \"),n(\"div\",{attrs:{align:\"center\"}},[n(\"img\",{attrs:{src:a(376),width:\"100%\"}})]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"所有要拼接的内容都会往StringBuilder中放，不会创建很多无用的空间，节约内存\")])]),t._v(\" \"),n(\"div\",{attrs:{align:\"center\"}},[n(\"img\",{attrs:{src:a(377),width:\"100%\"}})]),t._v(\" \"),n(\"div\",{attrs:{align:\"center\"}},[n(\"img\",{attrs:{src:a(378),width:\"100%\"}})]),t._v(\" \"),n(\"h3\",{attrs:{id:\"stringbuilder源码分析\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#stringbuilder源码分析\"}},[t._v(\"#\")]),t._v(\" StringBuilder源码分析\")]),t._v(\" \"),n(\"div\",{attrs:{align:\"left\"}},[n(\"img\",{attrs:{src:a(379),width:\"60%\"}})]),t._v(\" \"),n(\"h3\",{attrs:{id:\"static\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#static\"}},[t._v(\"#\")]),t._v(\" static\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[n(\"p\",[t._v(\"内存图\\n\")]),n(\"div\",{attrs:{align:\"left\"}},[n(\"img\",{attrs:{src:a(380),width:\"100%\"}})]),n(\"p\")]),t._v(\" \"),n(\"li\",[n(\"p\",[t._v(\"注意事项：\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"静态方法只能访问静态变量和静态方法\")]),t._v(\" \"),n(\"li\",[t._v(\"非静态方法可以访问静态变量或者静态方法，也可以访问非静态的成员变量和非静态的成员方法\")]),t._v(\" \"),n(\"li\",[t._v(\"静态方法中是没有this关键字\")])])])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"三种类\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#三种类\"}},[t._v(\"#\")]),t._v(\" 三种类\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"JavaBean类： 用来描述一类事物的类。比如，Student,Teacher,Dog,Cat等\")]),t._v(\" \"),n(\"li\",[t._v(\"测试类：用来检查其他类是否书写正确，带有main方法的类，是程序的入口\")]),t._v(\" \"),n(\"li\",[t._v(\"工具类：不是用来描述一类事物的，而是帮我们做一些事情的类。\"),n(\"br\"),t._v(\"\\n工具类构造时要：1.类名见名知义；2.私有化构造方法；3.方法定义为静态；\")])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"继承\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#继承\"}},[t._v(\"#\")]),t._v(\" 继承\")]),t._v(\" \"),n(\"ol\",[n(\"li\",[t._v(\"Java只能单继承：一个类只能继承一个直接父类；\")]),t._v(\" \"),n(\"li\",[t._v(\"Java不支持多继承、但是支持多层继承。\")]),t._v(\" \"),n(\"li\",[t._v(\"Java中所有的类都直接或者间接继承于Object类。（即Object类是所有类的原始父类）\")]),t._v(\" \"),n(\"li\",[t._v(\"子类只能访问父类中非私有的成员。\")])]),t._v(\" \"),n(\"ul\",[n(\"li\",[n(\"p\",[t._v(\"没有private\"),n(\"strong\",[t._v(\"成员变量\")]),t._v(\"继承的内存图\\n\")]),n(\"div\",{attrs:{align:\"left\"}},[n(\"img\",{attrs:{src:a(381),width:\"100%\"}})]),n(\"p\")]),t._v(\" \"),n(\"li\",[n(\"p\",[t._v(\"有private\"),n(\"strong\",[t._v(\"成员方法\")]),t._v(\"继承的内存图\\n\")]),n(\"div\",{attrs:{align:\"left\"}},[n(\"img\",{attrs:{src:a(382),width:\"100%\"}})]),t._v(\" \"),n(\"div\",{attrs:{align:\"left\"}},[n(\"img\",{attrs:{src:a(383),width:\"100%\"}})]),n(\"p\")]),t._v(\" \"),n(\"li\",[n(\"p\",[n(\"strong\",[t._v(\"虚方法表中的成员方法可以被继承，不在表中的成员方法不能被继承\")])])]),t._v(\" \"),n(\"li\",[n(\"p\",[t._v(\"继承中成员变量访问特点：\"),n(\"strong\",[t._v(\"就近原则\")]),n(\"br\"),t._v(\"\\n先在局部位置找，本类成员位置找，父类成员位置找，逐级往上\")])]),t._v(\" \"),n(\"li\",[n(\"p\",[t._v(\"若出现了重名的成员变量：\")])])]),t._v(\" \"),n(\"div\",{staticClass:\"language-java extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-java\"}},[n(\"code\",[n(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"System\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),t._v(\"out\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"println\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"name\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//从局部位置开始往上找\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"System\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),t._v(\"out\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"println\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"this\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),t._v(\"name\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),n(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//从本类成员位置开始往上找\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"System\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),t._v(\"out\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"println\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"super\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),t._v(\"name\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),n(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//从父类成员位置开始往上找\")]),t._v(\"\\n\")])])]),n(\"ul\",[n(\"li\",[t._v(\"方法重写的本质\\n\"),n(\"div\",{attrs:{align:\"left\"}},[n(\"img\",{attrs:{src:a(384),width:\"100%\"}})])])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"代码块\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#代码块\"}},[t._v(\"#\")]),t._v(\" 代码块\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"局部代码块(已淘汰)\"),n(\"br\"),t._v(\"\\n作用：提前结束变量的生命周期，节省空间\")]),t._v(\" \"),n(\"li\",[t._v(\"构造代码块（不够灵活）\\n\"),n(\"ul\",[n(\"li\",[t._v(\"写在成员位置的代码块\")]),t._v(\" \"),n(\"li\",[t._v(\"作用：可以把多个构造方法中重复的代码抽取出来\")]),t._v(\" \"),n(\"li\",[t._v(\"执行时机：再创建本类对象的时候会先执行构造代码块再执行构造方法\")])])]),t._v(\" \"),n(\"li\",[t._v(\"静态代码块（重点掌握）\\n\"),n(\"ul\",[n(\"li\",[t._v(\"格式：static{}\")]),t._v(\" \"),n(\"li\",[t._v(\"特点：需要通过static关键字修饰，随着类的加载而加载，并且自动触发、只执行一次\")]),t._v(\" \"),n(\"li\",[t._v(\"作用：数据的初始化\")])])])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"多态\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#多态\"}},[t._v(\"#\")]),t._v(\" 多态\")]),t._v(\" \"),n(\"p\",[t._v(\"格式：父类类型 变量名 = new 子类类型\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[n(\"p\",[t._v(\"调用成员变量时：\"),n(\"strong\",[t._v(\"编译看左边，运行看左边\")]),n(\"br\"),t._v(\"\\n编译看左边：javac编译代码的时候，会看左边的父类中有没有这个变量，如果有，编译成功，如果没有编译失败。\"),n(\"br\"),t._v(\"\\n运行看左边：java运行代码的时候，实际获取的就是左边父类中成员变量的值。\")])]),t._v(\" \"),n(\"li\",[n(\"p\",[t._v(\"调用成员方法时：\"),n(\"strong\",[t._v(\"编译看左边，运行看右边\")]),n(\"br\"),t._v(\"\\n编译看左边：javac编译代码的时候，会看左边的父类中有没有这个变量，如果有，编译成功，如果没有编译失败。\\n运行看右边：java运行代码的时候，实际上运行的是子类中的方法。\")])]),t._v(\" \"),n(\"li\",[n(\"p\",[t._v(\"能调用哪些方法，由引用类型决定，具体执行情况，由实际内存对象类型决定\")])]),t._v(\" \"),n(\"li\",[n(\"p\",[t._v(\"java执行方法时，会根据引用的类型得到相应的方法，如果不存在编译时会报错，真正执行时，会动态去匹配，如果真正的对象是子类的话，且此方法在子类中被覆盖的话，就会执行子类方法。\"),n(\"br\"),t._v(\"\\njava类型匹配时，如果不能匹配的话就做向上类型转换，转换为父类，直到能够匹配为止，若一直不能匹配在编译时会报错\")])])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"接口\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#接口\"}},[t._v(\"#\")]),t._v(\" 接口\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[n(\"strong\",[t._v(\"JDK7以前\")]),t._v(\"：接口中只能定义抽象方法。\")]),t._v(\" \"),n(\"li\",[n(\"strong\",[t._v(\"JDK8的新特性\")]),t._v(\"：接口中可以定义有方法体的方法。（默认方法、静态方法）\")]),t._v(\" \"),n(\"li\",[n(\"strong\",[t._v(\"JDK9的新特性\")]),t._v(\"：接口中可以定义私有方法。\")])]),t._v(\" \"),n(\"h4\",{attrs:{id:\"jdk8以后接口中新增的默认方法\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jdk8以后接口中新增的默认方法\"}},[t._v(\"#\")]),t._v(\" JDK8以后接口中新增的默认方法\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[n(\"p\",[t._v(\"允许在接口中定义默认方法，需要使用关键字default修饰。\"),n(\"br\"),t._v(\"\\n作用：解决接口升级的问题\")])]),t._v(\" \"),n(\"li\",[n(\"p\",[t._v(\"接口中\"),n(\"strong\",[t._v(\"默认方法\")]),t._v(\"的定义格式：\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"格式：\"),n(\"code\",[t._v(\"public default 返回值类型 方法名（参数列表）{}\")])]),t._v(\" \"),n(\"li\",[t._v(\"范例：\"),n(\"code\",[t._v(\"public default void show() {}\")])])])]),t._v(\" \"),n(\"li\",[n(\"p\",[t._v(\"接口中默认方法的注意事项：\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"默认方法不是抽象方法，所以不强制被重写。但是如果被重写，重写的时候去掉default关键字。\")]),t._v(\" \"),n(\"li\",[t._v(\"public 可以省略，default 不能省略。\")]),t._v(\" \"),n(\"li\",[t._v(\"如果实现了多个接口，多个接口中存在相同名字的默认方法，子类就必须对该方法进行重写。\")])])])]),t._v(\" \"),n(\"h4\",{attrs:{id:\"jdk8以后接口中新增的静态方法\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jdk8以后接口中新增的静态方法\"}},[t._v(\"#\")]),t._v(\" JDK8以后接口中新增的静态方法\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[n(\"p\",[t._v(\"允许在接口中定义静态方法，需要用 static 修饰\")])]),t._v(\" \"),n(\"li\",[n(\"p\",[t._v(\"接口中\"),n(\"strong\",[t._v(\"静态方法\")]),t._v(\"的定义格式：\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"格式：\"),n(\"code\",[t._v(\"public static 返回值类型 方法名（参数列表）\")])]),t._v(\" \"),n(\"li\",[t._v(\"范例：\"),n(\"code\",[t._v(\"public static void show(){}\")])])])]),t._v(\" \"),n(\"li\",[n(\"p\",[t._v(\"接口中静态方法的注意事项：\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"静态方法只能通过接口名调用，不能通过实现类名或者对象名调用\")]),t._v(\" \"),n(\"li\",[t._v(\"public 可以省略，static 不能省略\")])])])]),t._v(\" \"),n(\"h4\",{attrs:{id:\"jdk9以后接口中新增的私有方法\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jdk9以后接口中新增的私有方法\"}},[t._v(\"#\")]),t._v(\" JDK9以后接口中新增的私有方法\")]),t._v(\" \"),n(\"p\",[n(\"strong\",[t._v(\"此方法只为接口提供服务，不需要外类访问\")])]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"接口中私有方法的定义格式：\\n\"),n(\"ul\",[n(\"li\",[t._v(\"格式1：\"),n(\"code\",[t._v(\"private 返回值类型 方法名（参数列表）{}\")]),n(\"br\"),t._v(\"\\n范例1：\"),n(\"code\",[t._v(\"private void show(){} //普通的私有方法，给默认方法服务的\")])]),t._v(\" \"),n(\"li\",[t._v(\"格式2：\"),n(\"code\",[t._v(\"private static 返回值类型 方法名 （参数列表）{}\")]),n(\"br\"),t._v(\"\\n范例2：\"),n(\"code\",[t._v(\"private static void method(){} //静态的私有方法，给静态方法服务的\")])])])])]),t._v(\" \"),n(\"h4\",{attrs:{id:\"接口的应用\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#接口的应用\"}},[t._v(\"#\")]),t._v(\" 接口的应用\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"接口代表规则，是行为的抽象。想要让哪个类拥有一个行为，就让这个类实现对应的接口就可以了。\")]),t._v(\" \"),n(\"li\",[t._v(\"当一个方法的参数是接口时，可以传递接口所有实现类的对象，这种方式称之为接口多态。\")])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"适配器设计模式\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#适配器设计模式\"}},[t._v(\"#\")]),t._v(\" 适配器设计模式\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。\"),n(\"br\"),t._v(\"\\n使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。\"),n(\"br\"),t._v(\" \"),n(\"strong\",[t._v(\"简单理解：设计模式就是各种套路。\")])]),t._v(\" \"),n(\"li\",[t._v(\"适配器设计模式：解决接口与接口实现类之间的矛盾问题。\")]),t._v(\" \"),n(\"li\",[t._v(\"当一个接口中抽象方法过多，但是只要使用其中一部分的时候，就可以使用适配器设计模式\")]),t._v(\" \"),n(\"li\",[t._v(\"书写步骤：\"),n(\"br\"),t._v(\"\\n编写中间类XXXAdapter，实现对应的接口\"),n(\"br\"),t._v(\"\\n对接口中的抽象方法进行空实现\\n让真正的实现类继承中间类，并重写需要用的方法\\n为了避免其他类创建适配器类的对象，中间的适配器类用 abstract 进行修饰\")])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"内部类\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#内部类\"}},[t._v(\"#\")]),t._v(\" 内部类\")]),t._v(\" \"),n(\"p\",[t._v(\"类的五大成员：属性、方法、构造方法、代码块、内部类\"),n(\"br\"),t._v(\"\\n内部类的访问特点：\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"内部类可以直接访问外部类的成员，包括私有\")]),t._v(\" \"),n(\"li\",[t._v(\"外部类要访问内部类的成员，必须创建对象\")])]),t._v(\" \"),n(\"h2\",{attrs:{id:\"常用api\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#常用api\"}},[t._v(\"#\")]),t._v(\" 常用API\")]),t._v(\" \"),n(\"h3\",{attrs:{id:\"system\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#system\"}},[t._v(\"#\")]),t._v(\" System\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"也是一个工具类，提供了一些与系统相关的方法\")]),t._v(\" \"),n(\"li\",[t._v(\"时间原点：1970年1月1日 0:0:0，我国在东八区，有8小时时差，因此原点为1970年1月1日 8:0:0\")]),t._v(\" \"),n(\"li\",[t._v(\"1秒 = 1000 毫秒\")]),t._v(\" \"),n(\"li\",[t._v(\"常见方法\\n\"),n(\"ul\",[n(\"li\",[t._v(\"exit：停止虚拟机\")]),t._v(\" \"),n(\"li\",[t._v(\"currentTimeMillis：过去当前时间的毫秒值\")]),t._v(\" \"),n(\"li\",[t._v(\"arraycopy：拷贝数组\")])])])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"runtime\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#runtime\"}},[t._v(\"#\")]),t._v(\" Runtime\")]),t._v(\" \"),n(\"p\",[t._v(\"表示当前虚拟机的运行环境，是一个类但不能直接建立对象，要用 getRuntime 获取.\")]),t._v(\" \"),n(\"div\",{staticClass:\"language-java extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-java\"}},[n(\"code\",[n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"public\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"static\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"Runtime\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"getRuntime\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//当前系统的运行环境对象\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"public\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"exit\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"int\")]),t._v(\" status\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"       \"),n(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//停止虚拟机\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"public\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"int\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"availableProcessors\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"   \"),n(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//获得CPU的线程数\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"public\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"long\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"maxMemory\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"            \"),n(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//JVM能从系统钟获取总内存大小（单位byte）\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"public\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"long\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"totalMemory\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"          \"),n(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//JVM已经从系统中获取总内存大小（单位byte）\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"public\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"long\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"freeMemory\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"           \"),n(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//JVM剩余内存大小（单位byte）\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"public\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"Process\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"exec\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"String\")]),t._v(\" command\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//运行 cmd 命令\")]),t._v(\"\\n\")])])]),n(\"h2\",{attrs:{id:\"正则表达式\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#正则表达式\"}},[t._v(\"#\")]),t._v(\" 正则表达式\")]),t._v(\" \"),n(\"h3\",{attrs:{id:\"捕获分组-默认\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#捕获分组-默认\"}},[t._v(\"#\")]),t._v(\" 捕获分组（默认）\")]),t._v(\" \"),n(\"p\",[t._v(\"可以获取每组中的内容反复使用，以左括号为基准，最左边的是第一组\"),n(\"br\"),t._v(\"\\n后续还要继续使用本组的数据：\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"正则内部使用：\\\\组号\")]),t._v(\" \"),n(\"li\",[t._v(\"正则外部使用：$组号\")])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"非捕获分组\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#非捕获分组\"}},[t._v(\"#\")]),t._v(\" 非捕获分组\")]),t._v(\" \"),n(\"p\",[t._v(\"特点：不占用组号\\n\")]),n(\"div\",{attrs:{align:\"left\"}},[n(\"img\",{attrs:{src:a(385),width:\"100%\"}})]),n(\"p\"),t._v(\" \"),n(\"h2\",{attrs:{id:\"lambda表达式-jdk8后\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#lambda表达式-jdk8后\"}},[t._v(\"#\")]),t._v(\" Lambda表达式（JDK8后）\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"函数式编程（Functional programming）是一种思想特点，忽略面向对象的复杂语法，强调做什么，而不是谁去做。Lambda表达式就是函数式思想的体现。\")]),t._v(\" \"),n(\"li\",[t._v(\"面向对象：先找对象，让对象做事情\")]),t._v(\" \"),n(\"li\",[t._v(\"注意点：\\n\"),n(\"ul\",[n(\"li\",[t._v(\"Lambda表达式可以用来简化匿名内部类的书写\")]),t._v(\" \"),n(\"li\",[t._v(\"Lambda表达式只能简化函数式接口的匿名内部类的写法\")]),t._v(\" \"),n(\"li\",[t._v(\"函数式接口：有且仅有一个抽象方法的接口叫做函数式接口，接口上方可以加@FunctionalInterface注解\")])])]),t._v(\" \"),n(\"li\",[t._v(\"Lambda的省略规则：\\n\"),n(\"ul\",[n(\"li\",[t._v(\"1.参数类型可以省略不写\")]),t._v(\" \"),n(\"li\",[t._v(\"2.如果只有一个参数，参数类型可以省略，同时()也可以省略\")]),t._v(\" \"),n(\"li\",[t._v(\"3.如果Lambda表达式的方法体只有一行，大括号，分号，return可以省略不写，需要同时省略。\")])])])]),t._v(\" \"),n(\"div\",{staticClass:\"language-java extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-java\"}},[n(\"code\",[n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"->\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\"\\n\")])])]),n(\"h2\",{attrs:{id:\"集合\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#集合\"}},[t._v(\"#\")]),t._v(\" 集合\")]),t._v(\" \"),n(\"h3\",{attrs:{id:\"单列集合体系结构\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#单列集合体系结构\"}},[t._v(\"#\")]),t._v(\" 单列集合体系结构\")]),t._v(\" \"),n(\"div\",{attrs:{align:\"left\"}},[n(\"img\",{attrs:{src:a(386),width:\"100%\"}})]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"List系列集合：添加的元素是有序的（指存和取的顺序一样）、可重复的、有索引的。\")]),t._v(\" \"),n(\"li\",[t._v(\"Set系列集合：添加的元素是无序（指存和取的顺序不一定一样）、不重复、无索引（不能通过索引获取元素）。\")])]),t._v(\" \"),n(\"p\",[t._v(\"Collection：Collection是单列集合的祖宗\"),n(\"strong\",[t._v(\"接口\")]),t._v(\"，它的功能是全部单列集合都可以继承使用的。\\n\")]),n(\"div\",{attrs:{align:\"left\"}},[n(\"img\",{attrs:{src:a(387),width:\"100%\"}})]),n(\"p\"),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"Collection集合遍历方式\\n\"),n(\"ul\",[n(\"li\",[t._v(\"迭代器遍历：在遍历过程中需要删除元素，请使用迭代器\")]),t._v(\" \"),n(\"li\",[t._v(\"增强for遍历：仅仅想遍历\")]),t._v(\" \"),n(\"li\",[t._v(\"Lambda表达式遍历：仅仅想遍历\")])])])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"迭代器遍历\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#迭代器遍历\"}},[t._v(\"#\")]),t._v(\" 迭代器遍历\")]),t._v(\" \"),n(\"div\",{attrs:{align:\"left\"}},[n(\"img\",{attrs:{src:a(388),width:\"100%\"}})]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"1.当强行获取超出索引的元素，会报错NoSuchElementException\")]),t._v(\" \"),n(\"li\",[t._v(\"2.迭代器遍历完毕，指针不会复位\")]),t._v(\" \"),n(\"li\",[t._v(\"3.循环中只能用一次next方法\")]),t._v(\" \"),n(\"li\",[t._v(\"4.迭代器遍历集合时不依赖索引，不能用集合的方法进行增加或者删除，删除可以用迭代器提供的方法remove()进行删除\")])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"增强for遍历\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#增强for遍历\"}},[t._v(\"#\")]),t._v(\" 增强for遍历\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"增强for的底层就是迭代器，为了简化迭代器的代码书写的。\")]),t._v(\" \"),n(\"li\",[t._v(\"它是JDK5之后才出现的，其内部原理就是一个Iterator迭代器\")]),t._v(\" \"),n(\"li\",[t._v(\"所有的单列集合和数组才能用增强for进行遍历，双列集合不能用增强for遍历\")])]),t._v(\" \"),n(\"div\",{staticClass:\"language-java extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-java\"}},[n(\"code\",[n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"for\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"元素的数据类型 变量名 \"),n(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\":\")]),t._v(\" 数组或者集合\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\"\\n\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"for\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"String\")]),t._v(\" s \"),n(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\":\")]),t._v(\" list\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n  \"),n(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"System\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),t._v(\"out\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"println\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"s\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\"\\n\")])])]),n(\"ul\",[n(\"li\",[t._v(\"增强for细节：\\n\"),n(\"ul\",[n(\"li\",[t._v(\"修改增强for中的第三方变量，不会改变集合中原本的数据。\")])])])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"lambda表达式遍历\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#lambda表达式遍历\"}},[t._v(\"#\")]),t._v(\" Lambda表达式遍历\")]),t._v(\" \"),n(\"div\",{staticClass:\"language-java extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-java\"}},[n(\"code\",[n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"default\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"forEach\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"Consumer\")]),n(\"span\",{pre:!0,attrs:{class:\"token generics\"}},[n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"<\")]),n(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"?\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"super\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"T\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\">\")])]),t._v(\" action\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n\\ncoll\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"forEach\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"new\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"Consumer\")]),n(\"span\",{pre:!0,attrs:{class:\"token generics\"}},[n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"<\")]),n(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"String\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\">\")])]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n  \"),n(\"span\",{pre:!0,attrs:{class:\"token annotation punctuation\"}},[t._v(\"@Override\")]),t._v(\"\\n  \"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"public\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"accept\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"String\")]),t._v(\" s\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n    \"),n(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"System\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),t._v(\"out\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"println\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"s\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n  \"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// Lambda表达式形式\")]),t._v(\"\\ncoll\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"forEach\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"s \"),n(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"->\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"System\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),t._v(\"out\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"println\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"s\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"/*forEach底层原理：遍历集合，依次得到每一个元素，把得到的每一个元素，传递给accept方法，s依次表示集合中的每一个数据*/\")]),t._v(\"\\n\")])])]),n(\"h3\",{attrs:{id:\"list集合\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#list集合\"}},[t._v(\"#\")]),t._v(\" List集合\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"有序：存和取的元素顺序一致\")]),t._v(\" \"),n(\"li\",[t._v(\"有索引：可以通过索引操作元素\")]),t._v(\" \"),n(\"li\",[t._v(\"可重复：存储的元素可以重复\")]),t._v(\" \"),n(\"li\",[t._v(\"Collection的方法List都继承了\")]),t._v(\" \"),n(\"li\",[t._v(\"List集合因为有索引，所以多了很多索引操作的方法\")])]),t._v(\" \"),n(\"div\",{attrs:{align:\"left\"}},[n(\"img\",{attrs:{src:a(389),width:\"100%\"}})]),t._v(\" \"),n(\"p\",[n(\"strong\",[t._v(\"注意：在调用方法时，如果方法出现了重载现象，优先调用实参和形参类型一致的那个方法\")])]),t._v(\" \"),n(\"p\",[t._v(\"List集合有五种遍历方式：\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"迭代器：在遍历过程中需要删除元素，请使用迭代器\")]),t._v(\" \"),n(\"li\",[t._v(\"列表迭代器（ListIterator，属于Iterator的子接口，add方法可以在遍历过程中添加元素）：在遍历过程中需要添加元素，请使用列表迭代器\")]),t._v(\" \"),n(\"li\",[t._v(\"增强for：仅仅想遍历\")]),t._v(\" \"),n(\"li\",[t._v(\"Lambda表达式：仅仅想遍历\")]),t._v(\" \"),n(\"li\",[t._v(\"普通for（结合size方法和get方法以及循环）：遍历时想操作索引，可以用普通for\")])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"arraylist集合\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#arraylist集合\"}},[t._v(\"#\")]),t._v(\" ArrayList集合\")]),t._v(\" \"),n(\"div\",{attrs:{align:\"left\"}},[n(\"img\",{attrs:{src:a(390),width:\"80%\"}})]),t._v(\" \"),n(\"p\",[t._v(\"其中变量size既表示集合中元素的个数，也表示下一个元素应存储的位置。\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"ArrayList底层第一次扩容的情况。\\n\"),n(\"div\",{attrs:{align:\"left\"}},[n(\"img\",{attrs:{src:a(391),width:\"100%\"}})])]),t._v(\" \"),n(\"li\",[t._v(\"ArrayList底层后续扩容的情况\\n\"),n(\"div\",{attrs:{align:\"left\"}},[n(\"img\",{attrs:{src:a(392),width:\"100%\"}})])])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"linkedlist集合\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#linkedlist集合\"}},[t._v(\"#\")]),t._v(\" LinkedList集合\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"底层数据结构是\"),n(\"strong\",[t._v(\"双链表\")]),t._v(\"，查询慢，增删快，但是如果操作的是首尾元素，速度也是极快的。\")]),t._v(\" \"),n(\"li\",[t._v(\"LinkedList本身多了很多直接操作\"),n(\"strong\",[t._v(\"首尾元素\")]),t._v(\"的特有API。\\n\"),n(\"div\",{attrs:{align:\"left\"}},[n(\"img\",{attrs:{src:a(393),width:\"100%\"}})]),n(\"br\"),t._v(\" \"),n(\"div\",{attrs:{align:\"left\"}},[n(\"img\",{attrs:{src:a(394),width:\"100%\"}})])])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"迭代器底层源码分析\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#迭代器底层源码分析\"}},[t._v(\"#\")]),t._v(\" 迭代器底层源码分析\")]),t._v(\" \"),n(\"div\",{attrs:{align:\"left\"}},[n(\"img\",{attrs:{src:a(395),width:\"100%\"}})]),t._v(\" \"),n(\"h2\",{attrs:{id:\"数据结构\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#数据结构\"}},[t._v(\"#\")]),t._v(\" 数据结构\")]),t._v(\" \"),n(\"div\",{attrs:{align:\"left\"}},[n(\"img\",{attrs:{src:a(396),width:\"100%\"}})]),t._v(\" \"),n(\"h3\",{attrs:{id:\"栈\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#栈\"}},[t._v(\"#\")]),t._v(\" 栈\")]),t._v(\" \"),n(\"p\",[t._v(\"栈的特点：\"),n(\"strong\",[t._v(\"后进先出，先进后出\")]),n(\"br\"),t._v(\"\\n数据进入栈模型的过程称为：\"),n(\"strong\",[t._v(\"压/进栈\")]),n(\"br\"),t._v(\"\\n数据离开栈模型的过程称为：\"),n(\"strong\",[t._v(\"弹/出栈\")])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"队列\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#队列\"}},[t._v(\"#\")]),t._v(\" 队列\")]),t._v(\" \"),n(\"p\",[t._v(\"队列的特点：\"),n(\"strong\",[t._v(\"先进先出，后进后出\")]),n(\"br\"),t._v(\"\\n数据从\"),n(\"strong\",[t._v(\"后端\")]),t._v(\"进入队列模型的过程称为：\"),n(\"strong\",[t._v(\"入队列\")]),n(\"br\"),t._v(\"\\n数据从\"),n(\"strong\",[t._v(\"前端\")]),t._v(\"离开队列模型的过程称为：\"),n(\"strong\",[t._v(\"出队列\")])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"数组\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#数组\"}},[t._v(\"#\")]),t._v(\" 数组\")]),t._v(\" \"),n(\"p\",[t._v(\"数组的特点：数组是一种\"),n(\"strong\",[t._v(\"查询快，增删慢\")]),t._v(\"的模型\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[n(\"strong\",[t._v(\"查询速度快\")]),t._v(\"：查询数据通过地址值和索引定位，查询任意数据耗时相同。（元素在内存中是连续存储的）\")]),t._v(\" \"),n(\"li\",[n(\"strong\",[t._v(\"删除效率低\")]),t._v(\"：要将原始数据删除，同时后面每个数据前移\")]),t._v(\" \"),n(\"li\",[n(\"strong\",[t._v(\"添加效率极低\")]),t._v(\"：添加位置后的每个数据后移，再添加元素\")])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"链表\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#链表\"}},[t._v(\"#\")]),t._v(\" 链表\")]),t._v(\" \"),n(\"p\",[t._v(\"链表中的每个元素称为\"),n(\"strong\",[t._v(\"结点\")]),t._v(\"，每个结点都是独立的对象，在内存中是不连续的，有其独立的存储位置（地址），每个结点包含数据值和下一个结点的地址。\"),n(\"br\"),t._v(\" \"),n(\"strong\",[t._v(\"链表查询慢，无论查询哪个数据都要从头开始找。\")]),n(\"br\"),t._v(\" \"),n(\"strong\",[t._v(\"链表增删相对快。\")]),n(\"br\")]),n(\"div\",{attrs:{align:\"left\"}},[n(\"img\",{attrs:{src:a(397),width:\"60%\"}})]),n(\"br\"),t._v(\" \"),n(\"div\",{attrs:{align:\"left\"}},[n(\"img\",{attrs:{src:a(398),width:\"80%\"}})]),n(\"p\"),t._v(\" \"),n(\"h3\",{attrs:{id:\"树\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#树\"}},[t._v(\"#\")]),t._v(\" 树\")]),t._v(\" \"),n(\"p\",[t._v(\"专属名词：节点（都是独立对象），父节点，左子节点，右子节点\\n\")]),n(\"div\",{attrs:{align:\"left\"}},[n(\"img\",{attrs:{src:a(399),width:\"60%\"}})]),n(\"p\"),t._v(\" \"),n(\"h2\",{attrs:{id:\"泛型\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#泛型\"}},[t._v(\"#\")]),t._v(\" 泛型\")]),t._v(\" \"),n(\"p\",[t._v(\"泛型：是JDK5中引入的特性，可以在编译阶段约束操作的数据类型，并进行检查。\"),n(\"br\"),t._v(\" \"),n(\"strong\",[t._v(\"泛型的格式\")]),t._v(\"：<数据类型>\"),n(\"br\"),t._v(\"\\n注意：泛型只能支持引用数据类型。\"),n(\"br\"),t._v(\"\\n使用泛型的原因：如果我们没有给集合指定类型，默认认为所有的数据类型都是Object类型，此时可以往集合中添加任意的数据类型。但带来一个坏处：我们在获取数据的时候，无法使用他的特有行为。\"),n(\"br\"),t._v(\"\\n扩展知识点：Java中的泛型是伪泛型\")]),t._v(\" \"),n(\"h3\",{attrs:{id:\"泛型的好处\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#泛型的好处\"}},[t._v(\"#\")]),t._v(\" 泛型的好处\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"统一数据类型\")]),t._v(\" \"),n(\"li\",[t._v(\"把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为在编译阶段类型就能确定下来。\")])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"泛型的细节\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#泛型的细节\"}},[t._v(\"#\")]),t._v(\" 泛型的细节\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"泛型中不能写基本数据类型\")]),t._v(\" \"),n(\"li\",[t._v(\"指定泛型的具体类型后，传递数据时，可以传入该类类型或者其子类类型\")]),t._v(\" \"),n(\"li\",[t._v(\"如果不写泛型，类型默认是\"),n(\"strong\",[t._v(\"Object\")])])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"泛型类\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#泛型类\"}},[t._v(\"#\")]),t._v(\" 泛型类\")]),t._v(\" \"),n(\"p\",[t._v(\"如果一个类不确定类型，那么这个类就可以定义为泛型类，在类名后面定义泛型。\")]),t._v(\" \"),n(\"h3\",{attrs:{id:\"泛型方法\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#泛型方法\"}},[t._v(\"#\")]),t._v(\" 泛型方法\")]),t._v(\" \"),n(\"p\",[t._v(\"方法中形参类型不确定时，\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[n(\"ol\",[n(\"li\",[t._v(\"可以使用类名后面定义的泛型\"),n(\"E\")],1)])]),t._v(\" \"),n(\"li\",[n(\"ol\",{attrs:{start:\"2\"}},[n(\"li\",[t._v(\"在方法申明上定义自己的泛型\")])])])]),t._v(\" \"),n(\"div\",{staticClass:\"language-java extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-java\"}},[n(\"code\",[t._v(\"修饰符 \"),n(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"<\")]),t._v(\"类型\"),n(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" 返回值类型 方法名\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"类型 变量名\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\"\\n\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"public\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token generics\"}},[n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"<\")]),n(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"T\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\">\")])]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"show\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"T\")]),t._v(\" t\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//此处可以理解为变量，但是不是用来记录数据的，而是记录类型的，可以写成：T、E、K、V等\")]),t._v(\"\\n\")])])]),n(\"h3\",{attrs:{id:\"泛型接口\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#泛型接口\"}},[t._v(\"#\")]),t._v(\" 泛型接口\")]),t._v(\" \"),n(\"div\",{staticClass:\"language-java extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-java\"}},[n(\"code\",[t._v(\"修饰符 \"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"interface\")]),t._v(\" 接口名\"),n(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"<\")]),t._v(\"类型\"),n(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\"\\n\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"public\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"interface\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"List\")]),n(\"span\",{pre:!0,attrs:{class:\"token generics\"}},[n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"<\")]),n(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"E\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\">\")])]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\"\\n\")])])]),n(\"p\",[t._v(\"泛型接口的两种使用方式：\")]),t._v(\" \"),n(\"ol\",[n(\"li\",[t._v(\"实现类给出具体的类型\")]),t._v(\" \"),n(\"li\",[t._v(\"实现类延续泛型，创建实现类对象时再确定类型\")])]),t._v(\" \"),n(\"h3\",{attrs:{id:\"泛型的继承和通配符\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#泛型的继承和通配符\"}},[t._v(\"#\")]),t._v(\" 泛型的继承和通配符\")]),t._v(\" \"),n(\"ul\",[n(\"li\",[t._v(\"泛型不具备继承性（不能通过多态传递子类对象），但是数据具备继承性（指定泛型的具体类型后，传递数据时，可以传入该类类型或者其子类类型）  \"),n(\"strong\",[t._v(\"还需理解\")])])]),t._v(\" \"),n(\"div\",{staticClass:\"language-java extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-java\"}},[n(\"code\",[n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"public\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"static\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"void\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"method\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"ArrayList\")]),n(\"span\",{pre:!0,attrs:{class:\"token generics\"}},[n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"<\")]),n(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"Animal\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\">\")])]),t._v(\" list\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\"\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),n(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//在调用method方法时只能是Animal类型，不能传递其子类，因为泛型不具备继承性\")]),t._v(\"\\n\\n\"),n(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"ArrayList\")]),n(\"span\",{pre:!0,attrs:{class:\"token generics\"}},[n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"<\")]),n(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"Ye\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\">\")])]),t._v(\" list1 \"),n(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"new\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"ArrayList\")]),n(\"span\",{pre:!0,attrs:{class:\"token generics\"}},[n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"<\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\">\")])]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\nlist1\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"add\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"new\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"Ye\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),n(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"//数据具备继承性\")]),t._v(\"\\nlist1\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"add\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"new\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"Fu\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\nlist1\"),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),n(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"add\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"new\")]),t._v(\" \"),n(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"Zi\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),n(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\")])])]),n(\"ul\",[n(\"li\",[t._v(\"泛型的通配符：\\n\"),n(\"ul\",[n(\"li\",[t._v(\"?也表示不确定的类型，可以进行类型范围的限定\")]),t._v(\" \"),n(\"li\",[t._v(\"? extends E ：表示可以传递E或者E的所有的子类类型\")]),t._v(\" \"),n(\"li\",[t._v(\"? super E ：表示可以传递E或者E所有的父类类型\")]),t._v(\" \"),n(\"li\",[t._v(\"应用场景：如果在定义类、方法、接口的时候，如果类型不确定，就可以定义泛型类、泛型方法、泛型接口。如果类型不确定，但是能知道以后只能传递某个继承体系中的，就可以使用泛型的通配符。\")])])])])])}),[],!1,null,null,null);s.default=r.exports}}]);","extractedComments":[]}