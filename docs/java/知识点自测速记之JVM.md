---
title: '知识点自测速记之JVM'
---

> 这篇文章以问答的形式用于快速回顾知识点以及用于自测。  
> 因为知识点相当多，即使在看时能够理解记住，但过后也往往只是有印象，大概知道是什么东西，但想回答出来却总是卡壳，看了忘，忘了看。因此，这篇文章用于帮助速记回忆，自测时可以由这些点延伸。  




## Java 内存区域
#### Java 虚拟机的内存区域是怎么分配的？   
堆（其中包括字符串常量池）、各个线程分配的内存（其中包括程序计数器、虚拟机栈、本地方法栈）   
本地内存（包括直接内存、元空间（元空间包括运行时常量池））**不属于**虚拟机运行时数据区域。

#### 什么是程序计数器？程序计数器有什么作用？
程序计数器是一块较小的内存，可以看作是当前线程所执行字节码的行号指示器。  
作用：改变程序计数器来依次读取指令；在多线程情况下记录当前线程执行的位置。

#### Java 虚拟机栈的生命周期？存入的是哪些信息？
Java 虚拟机栈的生命周期随线程创建而创建，随线程死亡而死亡。   
存入的是栈帧，栈帧随方法调用而入栈，随方法结束而出栈，无论是正常结束还是异常结束。  
栈帧组成：局部变量表、操作数栈、动态链接、方法返回地址。  
局部变量表：存放基本数据类型和对象引用。  
操作数栈：存放方法调用过程中产生的中间计算结果。  
动态链接：服务于一个方法需要调用其他方法的场景，将符号引用转换为调用方法的直接引用。  

#### 程序运行时栈可能会出现什么错误？
- `StackOverFlowError`：若栈的内存不允许动态扩展，线程请求栈的深度超过当前 Java 虚拟机栈最大深度。
- `OutOfMemoryError`：若栈的内存可以动态扩展（一般不允许），虚拟机在动态扩展栈时无法申请到足够的内存空间。

#### 本地方法栈的作用？
与虚拟机栈类似，但是虚拟机栈针对的是 Java 方法（也就是字节码），而本地方法栈针对的是本地方法。

#### 堆是什么？堆有什么作用？
Java 虚拟机所管理内存最大的一块，也是所有线程共享的一块内存区域，在虚拟机启动时创建。  
作用：存放对象实例，几乎所有的对象实例以及数组都在堆中分配内存。

#### 堆内存有哪几部分？
- 新生代（包括 Eden 和 Survivor）  
- 老年代（Old）  
- 永久代（Permanent，后面变为元空间，元空间使用的是本地内存）

#### 对象在堆中各部分的迁移过程？
大部分情况，对象会首先在 Eden 分配，在一次新生代垃圾回收后，如果对象存活，就进入 S0 或 S1，并且对象年龄加 1，当年龄达到一定程度，就会晋升到老年代。具体是，Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累计的某个年龄超过了 Survivor 区的一半，取该年龄和预设的 `MaxTenuringThreshold` 中更小的一个作为年龄晋升阈值。


#### 堆最容易出现的错误？
- `java.lang.OutOfMemoryError：Overhead Limit Exceeded`：JVM 花太多时间回收垃圾并且只能回收很少的堆空间。
- `java.lang.OutOfMemoryError：Java heap space`：创建对象时堆空间不足。

#### 什么是方法区？方法区和永久代、元空间的关系？
方法区是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。  
方法区是逻辑概念，好比是类。而永久代、元空间是方法区的实现，相当于是实例。

#### 为什么要将永久代替换为元空间？
元空间使用本地内存，空间大小比永久代大，也因此可以加载的类数更多。

#### 方法区存放哪些信息？
方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

#### 方法区常用参数有哪些？
- `-XX:MetaspaceSize=N`：初始大小
- `-XX:MaxMetaspaceSize`：最大大小

#### 运行时常量池的作用？
用于存放编译期生成的各种字面量和符号引用。  
字面量：包括整数、浮点数、字符串字面量。  
符号引用：类符号引用、字段符号引用、方法符号引用、接口符号引用。

#### 字符串常量池是什么？作用？
JVM 为了提高性能和减少内存消耗针对字符串专门开辟的一块区域。   
作用：避免字符串的重复创建。

#### 字符串常量池中保存的是什么？
- 字符串字面量
- 通过String类的intern()方法添加的字符串
- 编译器优化的字符串（比如将多个字符串合并为一个）

#### JDK1.7 为什么要将字符串常量池从永久代移动到堆中？
永久代的GC回收效率太低，只有在Full GC的时候才会被执行GC，而程序中通常有大量被创建的字符串等待回收。

#### 直接内存和堆外内存是什么？
直接内存是一种特殊的内存缓冲区，通过Java NIO（New I/O）库中的 java.nio.ByteBuffer 来分配和管理的一种内存区域。它既不是虚拟机运行时数据区域的一部分，也不是虚拟机规范中定义的内存区域。   
堆外内存是在 Java 堆之外分配的内存区域，包括直接内存和其他方式分配的内存。

#### Java 对象的创建过程是怎样的？（重点）
类加载检查 -> 分配内存 -> 初始化零值（数据类型对应的零值）-> 设置对象头（类、类元数据信息、哈希码、GC分代年龄等） -> 执行init方法

#### 内存分配有哪两种方式？
指针碰撞、空闲列表

#### 内存分配并发有哪两种方式保证线程安全？
- CAS + 失败重试
- TLAB：为每一个线程预先在 Eden 区分配一块内存，在给线程中的对象分配内存时首先在 TLAB 中分配，TLAB 不够分配时再采用 CAS 进行内存分配。

#### 对象的内存布局是怎样的？
对象头、实例数据、对齐填充（仅起占位作用）

#### 对象的访问定位有哪几种方式？
Java 程序通过栈上的 reference 数据来操作堆上的具体对象。
- 使用句柄：reference 存储对象句柄地址，句柄中存储 到对象实例数据的指针 和 到对象类型数据的指针。
- 直接指针：reference 直接存储对象的地址。



## JVM 垃圾回收 GC 

#### Java 自动内存管理指的是什么？
对象内存的分配与回收

#### Java 堆的基本结构？
新生代、老年代、永久代/元空间

#### 内存分配和回收原则是什么？
- 对象优先在 Eden 区分配
- 大对象直接进行老年代
- 长期存活的对象将进入老年代

#### 主要进行 GC 的区域是哪？
根据 GC 策略：Partial GC：Minor/Young GC、Major/Old GC、Full GC

#### 空间分配担保是什么？

#### 死亡对象的判断方法有哪些？
引用计数法、可达性分析法

#### 哪些对象可以作为 GC Roots？

#### 对象可以被回收，就一定会被回收吗？
标记、筛选、标记

#### 引用有哪几种类型？
强引用、软引用、弱引用、虚引用

#### 如何判断常量池中一个常量是废弃常量？
eg. 字符串常量池中没有任何对象引用该常量

#### 如何判断一个类是无用的类？
三个条件：实例、类加载器、Class 对象

#### 垃圾收集的算法有哪些？
标记-清除、标记-复制、标记-整理、分代收集

#### Hotspot 为什么要分为新生代和老年代？
对象存活周期不同   
新生代：标记-复制
老年代：标记-清除/整理

#### 什么是垃圾收集器？有哪些垃圾收集器？
- Serial
- ParNew
- Parallel Scavenge
- Serial Old
- Parallel Old
- CMS（重点收集器）
- G1（重点收集器）
- ZGC




## 类文件结构
- 魔数
- Class 文件版本号
- 常量池
- 访问标志
- （当前类、父类、接口）索引集合
- 字段表集合
- 方法表集合
- 属性表集合



## 类加载过程

#### 类的生命周期各个阶段？
- 加载：类加载器加载
- 连接：分为验证、准备、解析三个阶段
- 初始化
- 使用
- 卸载（Class 对象被 GC）

#### 系统加载 Class 文件的步骤？
加载 -> 连接 -> 初始化   
连接：验证（是否合法）-> 准备（方法区分配空间、设置零值）-> 解析（符号引用转为直接引用）



## 类加载器详解

#### 加载所做的事有哪些？
- 获取类的二进制字节流
- 将字节流代表的静态存储结构转换为方法区的运行时数据结构
- 生成 Class 对象，作为方法区数据访问入口

#### 类加载器加载规则是什么？
- 根据需要动态加载
- 相同二进制名称的类只会被加载一次

#### JVM 内置的三个重要的 ClassLoader？
- BootstrapClassLoader（启动类加载器）
- ExtensionClassLoader（扩展类加载器）
- AppClassLoader（应用程序类加载器）

#### 获取到 ClassLoader 为 null 为什么就是 BootstrapClassLoader 加载的？
BootstrapClassLoader 是由 C++ 实现的

#### 自定义类加载器要怎么做？
继承 Java.lang.ClassLoader 抽象类，并重写两个重要方法之一：
`loadClass()`：会打破双亲委派模型
`findClass()`：不会打破双亲委派模型，建议使用这个

#### 类的双亲委派模型是什么？
各种类加载器之间的层次关系

#### 类加载器之间的父子关系是怎么实现的？
不是通过继承实现的，而是通过组合实现的，在类中引用父加载器的实例来复用父加载器代码。

#### 双亲委派模型的执行流程？
1. 检查当前类是否已加载（每个父加载器都查一遍）
2. 委派给父加载器去加载(`loadClass()`)，父加载器无法完成，子加载器才会自己去尝试加载(`findClass()`)
3. 如果子加载器也无法加载，抛出 `ClassNotFoundException`

#### JVM 判定两个 Java 类是否相同的具体规则？
- 类的全名
- 类加载器

#### 为什么 SPI 需要自定义类加载器？
SPI 由核心库提供，实现是由第三方提供的。   
本来应该由 SPI 接口的加载器（BootstrapClassLoader）加载实现类，但它是找不到的。

#### 什么是线程上下文类加载器？
将一个类加载器保存在线程私有数据与线程绑定，需要时取出使用 ContextClassLoader。  
如果没有设置，继承父线程的上下文类加载器。