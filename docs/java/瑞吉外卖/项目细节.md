

## 数据库部分

### employee表
- 创建时sql语句 `collate utf8_bin` 表示将输入的字符以二进制形式存储，因此数据会区分大小写
- 创建时sql语句 `comment '注释'` 表示字段的注释
- `using BTREE`：表示用BTREE来创建索引，提高查询效率。mysql中索引的存储类型有两种:BTREE和HASH,具体和表的存储引擎相关。
- `UNIQUE KEY 'idx_username' ('username')` ：括号中的是字段 `username` ，表示唯一约束，而 `idx_username` 表示对应的索引名。mysql中的key有两个作用，一是对字段约束，二是表示索引。


## 与数据库的表对应的实体类
 ### Employee类
 - `@TableField(fill = FieldFill.INSERT)`表示自动填充，`INSERT`表示新增时自动填充，`INSERT_UPDATE`表示新增和修改都自动填充，`DELETE`表示删除时自动填充。
 - `Serializable`接口：**实现序列化**。[参考文章](https://blog.csdn.net/ZHI_YUE/article/details/125124161)
   - 序列化：：对象的寿命通常随着生成该对象的程序的终止而终止，有时候需要把在内存中的各种对象的状态（也就是实例变量，不是方法）保存下来，并且可以在需要时再将对象恢复。Java提供一种保存对象状态的机制，那就是序列化。
   - 序列化的用途：需要把内存中的对象状态保存到一个文件中或者数据库中时候；需要把对象通过网络进行传播的时候。
   - `serialVersionUID`：序列化 ID 提供了两种生成策略：一个是固定的 1L；一个是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段。如果保存或传输前后的serialVersionUID不一致，那么反序列化就不能正常进行。（注：假设客户端A与客户端B中有一个serialVersionUID相同但字段不完全相同的Student类，进行反序列化时，仅会保留当前执行反序列化这一端的Student类的字段,另一端的不同字段将会被遗漏）


## 登录功能
### 拦截器中判断登录状态
- 前端页面`request.js`中已有前端页面的拦截器来判断登录状态，若后端返回数据结果状态码为0且`msg==NOTLOGIN`，则跳转到登录界面。因此，后端的拦截器中判断出未登录后不需要自己设置跳转到登录界面，只需要设置返回对象向客户端响应数据。