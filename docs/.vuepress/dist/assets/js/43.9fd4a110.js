(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{679:function(e,t,_){"use strict";_.r(t);var a=_(18),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,_=e._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h2",{attrs:{id:"数据库部分"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据库部分"}},[e._v("#")]),e._v(" 数据库部分")]),e._v(" "),_("h3",{attrs:{id:"employee表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#employee表"}},[e._v("#")]),e._v(" employee表")]),e._v(" "),_("ul",[_("li",[e._v("创建时sql语句 "),_("code",[e._v("collate utf8_bin")]),e._v(" 表示将输入的字符以二进制形式存储，因此数据会区分大小写")]),e._v(" "),_("li",[e._v("创建时sql语句 "),_("code",[e._v("comment '注释'")]),e._v(" 表示字段的注释")]),e._v(" "),_("li",[_("code",[e._v("using BTREE")]),e._v("：表示用BTREE来创建索引，提高查询效率。mysql中索引的存储类型有两种:BTREE和HASH,具体和表的存储引擎相关。")]),e._v(" "),_("li",[_("code",[e._v("UNIQUE KEY 'idx_username' ('username')")]),e._v(" ：括号中的是字段 "),_("code",[e._v("username")]),e._v(" ，表示唯一约束，而 "),_("code",[e._v("idx_username")]),e._v(" 表示对应的索引名。mysql中的key有两个作用，一是对字段约束，二是表示索引。")])]),e._v(" "),_("h2",{attrs:{id:"与数据库的表对应的实体类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#与数据库的表对应的实体类"}},[e._v("#")]),e._v(" 与数据库的表对应的实体类")]),e._v(" "),_("h3",{attrs:{id:"employee类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#employee类"}},[e._v("#")]),e._v(" Employee类")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("@TableField(fill = FieldFill.INSERT)")]),e._v("表示自动填充，"),_("code",[e._v("INSERT")]),e._v("表示新增时自动填充，"),_("code",[e._v("INSERT_UPDATE")]),e._v("表示新增和修改都自动填充，"),_("code",[e._v("DELETE")]),e._v("表示删除时自动填充。")]),e._v(" "),_("li",[_("code",[e._v("Serializable")]),e._v("接口："),_("strong",[e._v("实现序列化")]),e._v("。"),_("a",{attrs:{href:"https://blog.csdn.net/ZHI_YUE/article/details/125124161",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考文章"),_("OutboundLink")],1),e._v(" "),_("ul",[_("li",[e._v("序列化：：对象的寿命通常随着生成该对象的程序的终止而终止，有时候需要把在内存中的各种对象的状态（也就是实例变量，不是方法）保存下来，并且可以在需要时再将对象恢复。Java提供一种保存对象状态的机制，那就是序列化。")]),e._v(" "),_("li",[e._v("序列化的用途：需要把内存中的对象状态保存到一个文件中或者数据库中时候；需要把对象通过网络进行传播的时候。")]),e._v(" "),_("li",[_("code",[e._v("serialVersionUID")]),e._v("：序列化 ID 提供了两种生成策略：一个是固定的 1L；一个是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段。如果保存或传输前后的serialVersionUID不一致，那么反序列化就不能正常进行。（注：假设客户端A与客户端B中有一个serialVersionUID相同但字段不完全相同的Student类，进行反序列化时，仅会保留当前执行反序列化这一端的Student类的字段,另一端的不同字段将会被遗漏）")])])])]),e._v(" "),_("h2",{attrs:{id:"登录功能"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#登录功能"}},[e._v("#")]),e._v(" 登录功能")]),e._v(" "),_("h3",{attrs:{id:"拦截器中判断登录状态"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#拦截器中判断登录状态"}},[e._v("#")]),e._v(" 拦截器中判断登录状态")]),e._v(" "),_("ul",[_("li",[e._v("前端页面"),_("code",[e._v("request.js")]),e._v("中已有前端页面的拦截器来判断登录状态，若后端返回数据结果状态码为0且"),_("code",[e._v("msg==NOTLOGIN")]),e._v("，则跳转到登录界面。因此，后端的拦截器中判断出未登录后不需要自己设置跳转到登录界面，只需要设置返回对象向客户端响应数据。")])])])}),[],!1,null,null,null);t.default=s.exports}}]);