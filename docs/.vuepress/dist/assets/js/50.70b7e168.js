(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{665:function(a,t,v){"use strict";v.r(t);var _=v(18),r=Object(_.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("blockquote",[v("p",[a._v("这篇文章以问答的形式用于快速回顾知识点以及用于自测。"),v("br"),a._v("\n因为知识点相当多，即使在看时能够理解记住，但过后也往往只是有印象，大概知道是什么东西，但想回答出来却总是卡壳，看了忘，忘了看。因此，这篇文章用于帮助速记回忆，自测时可以由这些点延伸。\n注：参考的主要是 Guide 哥的网站内容以及 chatGPT。")])]),a._v(" "),v("h2",{attrs:{id:"操作系统基础"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#操作系统基础"}},[a._v("#")]),a._v(" 操作系统基础")]),a._v(" "),v("h4",{attrs:{id:"什么是操作系统"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是操作系统"}},[a._v("#")]),a._v(" 什么是操作系统？")]),a._v(" "),v("h4",{attrs:{id:"操作系统内核与-cpu-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#操作系统内核与-cpu-的区别"}},[a._v("#")]),a._v(" 操作系统内核与 CPU 的区别？")]),a._v(" "),v("h4",{attrs:{id:"操作系统主要有哪些功能-从资源管理的角度来看"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#操作系统主要有哪些功能-从资源管理的角度来看"}},[a._v("#")]),a._v(" 操作系统主要有哪些功能（从资源管理的角度来看）？")]),a._v(" "),v("p",[a._v("进程和线程管理、存储管理、文件管理、设备管理、网络管理、安全管理")]),a._v(" "),v("h4",{attrs:{id:"常见的操作系统有哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常见的操作系统有哪些"}},[a._v("#")]),a._v(" 常见的操作系统有哪些？")]),a._v(" "),v("h4",{attrs:{id:"什么是用户态和内核态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是用户态和内核态"}},[a._v("#")]),a._v(" 什么是用户态和内核态？")]),a._v(" "),v("p",[a._v("进程访问资源的权限不同"),v("br"),a._v("\n用户态 -> 系统调用 -> 内核态")]),a._v(" "),v("h4",{attrs:{id:"为什么要有用户态和内核态-只有一个内核态不行吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么要有用户态和内核态-只有一个内核态不行吗"}},[a._v("#")]),a._v(" 为什么要有用户态和内核态？只有一个内核态不行吗？")]),a._v(" "),v("p",[a._v("安全性、只有内核态的话所有系统资源会共享")]),a._v(" "),v("h4",{attrs:{id:"用户态和内核态是如何切换的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#用户态和内核态是如何切换的"}},[a._v("#")]),a._v(" 用户态和内核态是如何切换的？")]),a._v(" "),v("p",[a._v("系统调用、中断、异常")]),a._v(" "),v("h4",{attrs:{id:"什么是系统调用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是系统调用"}},[a._v("#")]),a._v(" 什么是系统调用？")]),a._v(" "),v("p",[a._v("操作系统内核提供的一些接口用于访问操作系统底层资源")]),a._v(" "),v("h4",{attrs:{id:"系统调用的过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#系统调用的过程"}},[a._v("#")]),a._v(" 系统调用的过程？")]),a._v(" "),v("p",[a._v("程序用户态发起系统调用 -> 特权指令触发中断 Trap -> 内核态 -> 执行中断处理程序 -> 处理完成，主动触发 Trap -> 用户态。")]),a._v(" "),v("h2",{attrs:{id:"进程与线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程与线程"}},[a._v("#")]),a._v(" 进程与线程")]),a._v(" "),v("h4",{attrs:{id:"什么是进程与线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是进程与线程"}},[a._v("#")]),a._v(" 什么是进程与线程？")]),a._v(" "),v("p",[a._v("进程：一般是一个程序"),v("br"),a._v("\n线程：更小的运行单位")]),a._v(" "),v("h4",{attrs:{id:"线程和进程的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程和进程的区别"}},[a._v("#")]),a._v(" 线程和进程的区别？")]),a._v(" "),v("p",[a._v("资源的共享情况、独立性（进程与进程影响情况，线程与线程影响情况）、上下文切换消耗")]),a._v(" "),v("h4",{attrs:{id:"有了进程为什么还需要线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#有了进程为什么还需要线程"}},[a._v("#")]),a._v(" 有了进程为什么还需要线程？")]),a._v(" "),v("p",[a._v("切换开销、轻量级、并发情况、彼此之间的通信")]),a._v(" "),v("h4",{attrs:{id:"为什么要使用多线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么要使用多线程"}},[a._v("#")]),a._v(" 为什么要使用多线程？")]),a._v(" "),v("p",[a._v("切换开销、现代系统应用需求、单核情况、多核情况")]),a._v(" "),v("h4",{attrs:{id:"线程间的同步方式有哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程间的同步方式有哪些"}},[a._v("#")]),a._v(" 线程间的同步方式有哪些？")]),a._v(" "),v("p",[a._v("互斥锁、读写锁、信号量、屏障、事件")]),a._v(" "),v("h4",{attrs:{id:"pcb-是什么-包含哪些信息"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#pcb-是什么-包含哪些信息"}},[a._v("#")]),a._v(" PCB 是什么？包含哪些信息？")]),a._v(" "),v("p",[a._v("进程控制块（相当于进程的大脑）"),v("br"),a._v("\n包含进程的描述信息、调度信息、对资源的需求情况、打开的文件信息、处理机的状态信息")]),a._v(" "),v("h4",{attrs:{id:"进程有哪几种状态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程有哪几种状态"}},[a._v("#")]),a._v(" 进程有哪几种状态？")]),a._v(" "),v("p",[a._v("创建、就绪、运行、阻塞、结束")]),a._v(" "),v("h4",{attrs:{id:"进程间的通信-ipc-常见的有哪几种方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程间的通信-ipc-常见的有哪几种方式"}},[a._v("#")]),a._v(" 进程间的通信 IPC 常见的有哪几种方式？")]),a._v(" "),v("p",[a._v("管道/匿名管道（单向、内存）、有名管道（单向、磁盘文件、FIFO）、信号、消息队列（内核中）、信号量、共享内存、套接字")]),a._v(" "),v("h4",{attrs:{id:"进程的调度算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程的调度算法"}},[a._v("#")]),a._v(" 进程的调度算法？")]),a._v(" "),v("ul",[v("li",[a._v("先到先服务 FCFS")]),a._v(" "),v("li",[a._v("短作业优先 SJF")]),a._v(" "),v("li",[a._v("时间片轮转 Round-Robin")]),a._v(" "),v("li",[a._v("多级反馈队列调度算法 MFQ")]),a._v(" "),v("li",[a._v("优先级调度算法 Priority")])]),a._v(" "),v("h4",{attrs:{id:"僵尸进程和孤儿进程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#僵尸进程和孤儿进程"}},[a._v("#")]),a._v(" 僵尸进程和孤儿进程？")]),a._v(" "),v("ul",[v("li",[a._v("僵尸进程：子进程结束但 PCB 仍存在，父进程存在但没有调用 wait 或 waitpid 系统调用来释放子进程占用的资源")]),a._v(" "),v("li",[a._v("孤儿进程：子进程存在但父进程已经结束")])]),a._v(" "),v("h4",{attrs:{id:"如何查看是否有僵尸进程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何查看是否有僵尸进程"}},[a._v("#")]),a._v(" 如何查看是否有僵尸进程？")]),a._v(" "),v("p",[a._v("Linux 下 Top 命令")]),a._v(" "),v("h4",{attrs:{id:"什么是死锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是死锁"}},[a._v("#")]),a._v(" 什么是死锁？")]),a._v(" "),v("h4",{attrs:{id:"产生死锁的四个必要条件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#产生死锁的四个必要条件"}},[a._v("#")]),a._v(" 产生死锁的四个必要条件？")]),a._v(" "),v("p",[a._v("互斥、占有并等待、非抢占、循环等待")]),a._v(" "),v("h4",{attrs:{id:"解决死锁的方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解决死锁的方法"}},[a._v("#")]),a._v(" 解决死锁的方法？")]),a._v(" "),v("ul",[v("li",[a._v("预防：静态分配策略（提前分配所有资源）、层次分配策略（按序分配资源、只能申请更高层资源，释放反之）")]),a._v(" "),v("li",[a._v("避免：银行家算法、获取资源时判断是否安全")]),a._v(" "),v("li",[a._v("检测与解除：\n"),v("ul",[v("li",[a._v("检测：进程-资源分配图检测系统是否处于死锁状态")]),a._v(" "),v("li",[a._v("解除：重启操作系统、撤销涉及死锁进程等解除后继续执行、逐个撤销涉及死锁进程直至死锁节处、抢占资源")])])])]),a._v(" "),v("h2",{attrs:{id:"操作系统内存管理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#操作系统内存管理"}},[a._v("#")]),a._v(" 操作系统内存管理")]),a._v(" "),v("h4",{attrs:{id:"操作系统的内存管理主要是做什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#操作系统的内存管理主要是做什么"}},[a._v("#")]),a._v(" 操作系统的内存管理主要是做什么？")]),a._v(" "),v("p",[a._v("内存分配与回收、地址转换、内存扩充、内存映射、内存优化、内存安全")]),a._v(" "),v("h4",{attrs:{id:"什么是内存碎片"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是内存碎片"}},[a._v("#")]),a._v(" 什么是内存碎片？")]),a._v(" "),v("p",[a._v("内存申请和释放产生的，包括内部内存碎片（分配但未使用）、外部内存碎片（未分配但连续内存区域太小无法利用）")]),a._v(" "),v("h4",{attrs:{id:"常见的内存管理方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常见的内存管理方式"}},[a._v("#")]),a._v(" 常见的内存管理方式？")]),a._v(" "),v("ul",[v("li",[a._v("连续内存管理（分配一个连续的内存空间）：块式管理")]),a._v(" "),v("li",[a._v("非连续内存管理（允许内存离散）：段式管理（不同段有各自意义）、页式管理、段页式管理机制")])]),a._v(" "),v("h4",{attrs:{id:"什么是虚拟内存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是虚拟内存"}},[a._v("#")]),a._v(" 什么是虚拟内存？")]),a._v(" "),v("p",[a._v("一种重要的内存管理技术，通过将物理内存抽象成虚拟内存，为每个进程提供一个独立、连续的地址空间，使得每个进程都以为它拥有足够大的内存空间。")]),a._v(" "),v("h4",{attrs:{id:"虚拟内存有什么作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#虚拟内存有什么作用"}},[a._v("#")]),a._v(" 虚拟内存有什么作用？")]),a._v(" "),v("p",[a._v("隔离进程、提升物理内存利用率、简化内存管理、多个进程共享内存（公共库只会加载一份）、提高内存使用安全性（隔离不同进程的访问权限）、提供更大的可使用内存空间（磁盘充当内存）")]),a._v(" "),v("h4",{attrs:{id:"没有虚拟内存会有什么问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#没有虚拟内存会有什么问题"}},[a._v("#")]),a._v(" 没有虚拟内存会有什么问题？")]),a._v(" "),v("p",[a._v("用户可以访问任意物理内存、同时运行多个程序容易崩溃、内存利用率不高（程序运行所有数据和指令要载入，很大一部分用不到）")]),a._v(" "),v("h4",{attrs:{id:"什么是虚拟内存和物理地址"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是虚拟内存和物理地址"}},[a._v("#")]),a._v(" 什么是虚拟内存和物理地址？")]),a._v(" "),v("p",[a._v("物理地址：真正物理内存地址，内存地址寄存器的地址"),v("br"),a._v("\n虚拟地址：虚拟内存地址")]),a._v(" "),v("h4",{attrs:{id:"怎么将虚拟地址转换为物理地址"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#怎么将虚拟地址转换为物理地址"}},[a._v("#")]),a._v(" 怎么将虚拟地址转换为物理地址？")]),a._v(" "),v("p",[a._v("地址翻译/ 地址转换：操作系统通过 CPU 芯片的一个重要组件内存管理单元 MMU 进行转换。")]),a._v(" "),v("h4",{attrs:{id:"mmu-进行地址翻译的机制有哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mmu-进行地址翻译的机制有哪些"}},[a._v("#")]),a._v(" MMU 进行地址翻译的机制有哪些？")]),a._v(" "),v("p",[a._v("分页机制、分段机制、段页机制")]),a._v(" "),v("h4",{attrs:{id:"分段机制是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分段机制是什么"}},[a._v("#")]),a._v(" 分段机制是什么？")]),a._v(" "),v("p",[a._v("以段的形式管理/分配内存，各个段有各自的意义")]),a._v(" "),v("h4",{attrs:{id:"段表有什么用-对应的地址翻译过程是怎样的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#段表有什么用-对应的地址翻译过程是怎样的"}},[a._v("#")]),a._v(" 段表有什么用？对应的地址翻译过程是怎样的？")]),a._v(" "),v("p",[a._v("分段管理通过段表映射虚拟地址和物理地址。"),v("br"),a._v("\n分段机制下虚拟地址组成：段号 + 段内偏移量"),v("br"),a._v("\n段号 -> 段表查询段信息 -> 段起始地址 -> 加上偏移量")]),a._v(" "),v("h4",{attrs:{id:"通过段号一定找得到段表项吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#通过段号一定找得到段表项吗"}},[a._v("#")]),a._v(" 通过段号一定找得到段表项吗？")]),a._v(" "),v("p",[a._v("不一定，段表项被删除、段表项未创建")]),a._v(" "),v("h4",{attrs:{id:"分段机制为什么会导致内存外部碎片"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分段机制为什么会导致内存外部碎片"}},[a._v("#")]),a._v(" 分段机制为什么会导致内存外部碎片？")]),a._v(" "),v("p",[a._v("段与段之间碎片空间不足以映射给虚拟地址空间中的段")]),a._v(" "),v("h4",{attrs:{id:"分页机制是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分页机制是什么"}},[a._v("#")]),a._v(" 分页机制是什么？")]),a._v(" "),v("p",[a._v("把主存分为连续等长的物理页，应用程序虚拟地址空间也划分为连续等长的虚拟页。")]),a._v(" "),v("h4",{attrs:{id:"页表有什么用-对应的地址翻译过程是怎样的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#页表有什么用-对应的地址翻译过程是怎样的"}},[a._v("#")]),a._v(" 页表有什么用？对应的地址翻译过程是怎样的？")]),a._v(" "),v("p",[a._v("通过页表映射虚拟内存和物理内存。"),v("br"),a._v("\n分页机制下虚拟地址组成：页号 + 页内偏移量"),v("br"),a._v("\n页号 -> 页表中取出物理页号 -> 物理页起始地址 -> 加上偏移量")]),a._v(" "),v("h4",{attrs:{id:"通过虚拟页号一定找得到对应的物理页号吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#通过虚拟页号一定找得到对应的物理页号吗"}},[a._v("#")]),a._v(" 通过虚拟页号一定找得到对应的物理页号吗？")]),a._v(" "),v("p",[a._v("可能存在页缺失")]),a._v(" "),v("h4",{attrs:{id:"单级页表有什么问题-为什么需要多级页表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#单级页表有什么问题-为什么需要多级页表"}},[a._v("#")]),a._v(" 单级页表有什么问题？为什么需要多级页表？")]),a._v(" "),v("p",[a._v("占用内存高、开销大、效率低"),v("br"),a._v("\n32 位是二级页表，64 位是四级页表"),v("br"),a._v("\n多级页表通过增加页表查询次数减少页表占用空间")]),a._v(" "),v("h4",{attrs:{id:"tlb-是什么-有什么用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tlb-是什么-有什么用"}},[a._v("#")]),a._v(" TLB 是什么？有什么用？")]),a._v(" "),v("p",[a._v("TLB 是转址旁路缓存，也就是快表。它是一块高速缓存，缓存虚拟页号到物理页号的映射。")]),a._v(" "),v("h4",{attrs:{id:"换页机制有什么用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#换页机制有什么用"}},[a._v("#")]),a._v(" 换页机制有什么用？")]),a._v(" "),v("p",[a._v("扩充内存，当物理内存不够用时，将一些物理页的内存存到磁盘。")]),a._v(" "),v("h4",{attrs:{id:"什么是页缺失"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是页缺失"}},[a._v("#")]),a._v(" 什么是页缺失？")]),a._v(" "),v("p",[a._v("一个分页已映射在虚拟内存中，但是并未加载在物理内存中，由 MMU 发出的中断。"),v("br"),a._v("\n硬性页缺失：物理内存中没有对应的物理页，需从磁盘加载。"),v("br"),a._v("\n软性页缺失：物理内存中由对应的物理页，但还未与虚拟页建立映射。")]),a._v(" "),v("h4",{attrs:{id:"常见的页面置换算法有哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常见的页面置换算法有哪些"}},[a._v("#")]),a._v(" 常见的页面置换算法有哪些？")]),a._v(" "),v("ul",[v("li",[a._v("最佳页面置换算法：理论上最优，但无法实现")]),a._v(" "),v("li",[a._v("先进先出（FIFO）页面置换算法：淘汰最先进入内存的页面")]),a._v(" "),v("li",[a._v("最近最久未使用页面置换算法（LRU）")]),a._v(" "),v("li",[a._v("最少使用页面置换算法（LFU）")]),a._v(" "),v("li",[a._v("时钟页面置换算法（Clock）：一种最近未使用算法")])]),a._v(" "),v("h4",{attrs:{id:"fifo-页面置换算法性能为何不好"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#fifo-页面置换算法性能为何不好"}},[a._v("#")]),a._v(" FIFO 页面置换算法性能为何不好？")]),a._v(" "),v("p",[a._v("经常访问或者需要长期存在的页面会被频繁调入调出。"),v("br"),a._v("\n存在 Belady 现象：分配页面数增多但缺页率反而提高。")]),a._v(" "),v("h4",{attrs:{id:"哪一种页面置换算法实际用得比较多"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#哪一种页面置换算法实际用得比较多"}},[a._v("#")]),a._v(" 哪一种页面置换算法实际用得比较多？")]),a._v(" "),v("p",[a._v("LRU")]),a._v(" "),v("h4",{attrs:{id:"分页机制和分段机制的共同点和区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分页机制和分段机制的共同点和区别"}},[a._v("#")]),a._v(" 分页机制和分段机制的共同点和区别？")]),a._v(" "),v("ul",[v("li",[a._v("共同点：都是非连续内存管理的方式，都采用了地址映射的方式")]),a._v(" "),v("li",[a._v("区别：\n"),v("ul",[v("li",[a._v("分页以页为单位，分段以段为单位，页大小固定，段大小不固定，页是物理单位，段是逻辑单位")]),a._v(" "),v("li",[a._v("分段容易出现外部内存碎片，分页不会，但仍可能有内部碎片")]),a._v(" "),v("li",[a._v("分段用段表，分页用页表")]),a._v(" "),v("li",[a._v("分页对程序没有要求，分段需要将程序分段")])])])]),a._v(" "),v("h4",{attrs:{id:"段页机制是怎样的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#段页机制是怎样的"}},[a._v("#")]),a._v(" 段页机制是怎样的？")]),a._v(" "),v("p",[a._v("先分段，再将每个段分页。")]),a._v(" "),v("h4",{attrs:{id:"什么是局部性原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是局部性原理"}},[a._v("#")]),a._v(" 什么是局部性原理？")]),a._v(" "),v("p",[a._v("在程序执行过程中，数据和指令的访问存在一定的空间和时间上的局部性特点。"),v("br"),a._v("\n时间局部性：缓存（将最近访问过的一些页放入缓存，与页表不同）"),v("br"),a._v("\n空间局部性：预取技术（预先将相邻的页面读入内存缓存中）")]),a._v(" "),v("h4",{attrs:{id:"虚拟内存技术的实现一般需要哪三个东西"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#虚拟内存技术的实现一般需要哪三个东西"}},[a._v("#")]),a._v(" 虚拟内存技术的实现一般需要哪三个东西？")]),a._v(" "),v("p",[a._v("分页或分段机制、页表或段表、页面置换策略或段换入换出策略")]),a._v(" "),v("h2",{attrs:{id:"文件系统"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#文件系统"}},[a._v("#")]),a._v(" 文件系统")]),a._v(" "),v("h4",{attrs:{id:"文件系统主要做了什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#文件系统主要做了什么"}},[a._v("#")]),a._v(" 文件系统主要做了什么？")]),a._v(" "),v("p",[a._v("存储管理、文件管理、目录管理、文件访问控制")]),a._v(" "),v("h4",{attrs:{id:"文件链接-file-link-是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#文件链接-file-link-是什么"}},[a._v("#")]),a._v(" 文件链接（File Link）是什么？")]),a._v(" "),v("p",[a._v("一种特殊的文件类型，可以在文件系统中指向另一个文件")]),a._v(" "),v("h4",{attrs:{id:"常见的文件链接类型有哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常见的文件链接类型有哪些"}},[a._v("#")]),a._v(" 常见的文件链接类型有哪些？")]),a._v(" "),v("p",[a._v("硬链接、软链接")]),a._v(" "),v("h4",{attrs:{id:"提高文件系统性能的方式有哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#提高文件系统性能的方式有哪些"}},[a._v("#")]),a._v(" 提高文件系统性能的方式有哪些？")]),a._v(" "),v("p",[a._v("优化硬件、选择合适的文件系统选型、运用缓存、避免磁盘使用过度、对磁盘进行合理的分区")]),a._v(" "),v("h4",{attrs:{id:"常见的磁盘调度算法有哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常见的磁盘调度算法有哪些"}},[a._v("#")]),a._v(" 常见的磁盘调度算法有哪些？")]),a._v(" "),v("ul",[v("li",[a._v("先到先服务 FCFS")]),a._v(" "),v("li",[a._v("最短寻道时间优先算法 SSTF")]),a._v(" "),v("li",[a._v("扫描算法 SCAN")]),a._v(" "),v("li",[a._v("循环扫描算法 C-SCAN")]),a._v(" "),v("li",[a._v("边扫描边观察算法 LOOK")]),a._v(" "),v("li",[a._v("均衡循环扫描算法 C-LOOK")])])])}),[],!1,null,null,null);t.default=r.exports}}]);