(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{658:function(a,v,t){"use strict";t.r(v);var _=t(18),r=Object(_.a)({},(function(){var a=this,v=a.$createElement,t=a._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("blockquote",[t("p",[a._v("这篇文章以问答的形式用于快速回顾知识点以及用于自测。"),t("br"),a._v("\n因为知识点相当多，即使在看时能够理解记住，但过后也往往只是有印象，大概知道是什么东西，但想回答出来却总是卡壳，看了忘，忘了看。因此，这篇文章用于帮助速记回忆，自测时可以由这些点延伸。")])]),a._v(" "),t("h2",{attrs:{id:"java-内存区域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-内存区域"}},[a._v("#")]),a._v(" Java 内存区域")]),a._v(" "),t("h4",{attrs:{id:"java-虚拟机的内存区域是怎么分配的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-虚拟机的内存区域是怎么分配的"}},[a._v("#")]),a._v(" Java 虚拟机的内存区域是怎么分配的？")]),a._v(" "),t("p",[a._v("堆（其中包括字符串常量池）、各个线程分配的内存（其中包括程序计数器、虚拟机栈、本地方法栈）"),t("br"),a._v("\n本地内存（包括直接内存、元空间（元空间包括运行时常量池））"),t("strong",[a._v("不属于")]),a._v("虚拟机运行时数据区域。")]),a._v(" "),t("h4",{attrs:{id:"什么是程序计数器-程序计数器有什么作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是程序计数器-程序计数器有什么作用"}},[a._v("#")]),a._v(" 什么是程序计数器？程序计数器有什么作用？")]),a._v(" "),t("p",[a._v("程序计数器是一块较小的内存，可以看作是当前线程所执行字节码的行号指示器。"),t("br"),a._v("\n作用：改变程序计数器来依次读取指令；在多线程情况下记录当前线程执行的位置。")]),a._v(" "),t("h4",{attrs:{id:"java-虚拟机栈的生命周期-存入的是哪些信息"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-虚拟机栈的生命周期-存入的是哪些信息"}},[a._v("#")]),a._v(" Java 虚拟机栈的生命周期？存入的是哪些信息？")]),a._v(" "),t("p",[a._v("Java 虚拟机栈的生命周期随线程创建而创建，随线程死亡而死亡。"),t("br"),a._v("\n存入的是栈帧，栈帧随方法调用而入栈，随方法结束而出栈，无论是正常结束还是异常结束。"),t("br"),a._v("\n栈帧组成：局部变量表、操作数栈、动态链接、方法返回地址。"),t("br"),a._v("\n局部变量表：存放基本数据类型和对象引用。"),t("br"),a._v("\n操作数栈：存放方法调用过程中产生的中间计算结果。"),t("br"),a._v("\n动态链接：服务于一个方法需要调用其他方法的场景，将符号引用转换为调用方法的直接引用。")]),a._v(" "),t("h4",{attrs:{id:"程序运行时栈可能会出现什么错误"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#程序运行时栈可能会出现什么错误"}},[a._v("#")]),a._v(" 程序运行时栈可能会出现什么错误？")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("StackOverFlowError")]),a._v("：若栈的内存不允许动态扩展，线程请求栈的深度超过当前 Java 虚拟机栈最大深度。")]),a._v(" "),t("li",[t("code",[a._v("OutOfMemoryError")]),a._v("：若栈的内存可以动态扩展（一般不允许），虚拟机在动态扩展栈时无法申请到足够的内存空间。")])]),a._v(" "),t("h4",{attrs:{id:"本地方法栈的作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#本地方法栈的作用"}},[a._v("#")]),a._v(" 本地方法栈的作用？")]),a._v(" "),t("p",[a._v("与虚拟机栈类似，但是虚拟机栈针对的是 Java 方法（也就是字节码），而本地方法栈针对的是本地方法。")]),a._v(" "),t("h4",{attrs:{id:"堆是什么-堆有什么作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆是什么-堆有什么作用"}},[a._v("#")]),a._v(" 堆是什么？堆有什么作用？")]),a._v(" "),t("p",[a._v("Java 虚拟机所管理内存最大的一块，也是所有线程共享的一块内存区域，在虚拟机启动时创建。"),t("br"),a._v("\n作用：存放对象实例，几乎所有的对象实例以及数组都在堆中分配内存。")]),a._v(" "),t("h4",{attrs:{id:"堆内存有哪几部分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆内存有哪几部分"}},[a._v("#")]),a._v(" 堆内存有哪几部分？")]),a._v(" "),t("ul",[t("li",[a._v("新生代（包括 Eden 和 Survivor）")]),a._v(" "),t("li",[a._v("老年代（Old）")]),a._v(" "),t("li",[a._v("永久代（Permanent，后面变为元空间，元空间使用的是本地内存）")])]),a._v(" "),t("h4",{attrs:{id:"对象在堆中各部分的迁移过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象在堆中各部分的迁移过程"}},[a._v("#")]),a._v(" 对象在堆中各部分的迁移过程？")]),a._v(" "),t("p",[a._v("大部分情况，对象会首先在 Eden 分配，在一次新生代垃圾回收后，如果对象存活，就进入 S0 或 S1，并且对象年龄加 1，当年龄达到一定程度，就会晋升到老年代。具体是，Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累计的某个年龄超过了 Survivor 区的一半，取该年龄和预设的 "),t("code",[a._v("MaxTenuringThreshold")]),a._v(" 中更小的一个作为年龄晋升阈值。")]),a._v(" "),t("h4",{attrs:{id:"堆最容易出现的错误"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆最容易出现的错误"}},[a._v("#")]),a._v(" 堆最容易出现的错误？")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("java.lang.OutOfMemoryError：Overhead Limit Exceeded")]),a._v("：JVM 花太多时间回收垃圾并且只能回收很少的堆空间。")]),a._v(" "),t("li",[t("code",[a._v("java.lang.OutOfMemoryError：Java heap space")]),a._v("：创建对象时堆空间不足。")])]),a._v(" "),t("h4",{attrs:{id:"什么是方法区-方法区和永久代、元空间的关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是方法区-方法区和永久代、元空间的关系"}},[a._v("#")]),a._v(" 什么是方法区？方法区和永久代、元空间的关系？")]),a._v(" "),t("p",[a._v("方法区是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。"),t("br"),a._v("\n方法区是逻辑概念，好比是类。而永久代、元空间是方法区的实现，相当于是实例。")]),a._v(" "),t("h4",{attrs:{id:"为什么要将永久代替换为元空间"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么要将永久代替换为元空间"}},[a._v("#")]),a._v(" 为什么要将永久代替换为元空间？")]),a._v(" "),t("p",[a._v("元空间使用本地内存，空间大小比永久代大，也因此可以加载的类数更多。")]),a._v(" "),t("h4",{attrs:{id:"方法区存放哪些信息"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法区存放哪些信息"}},[a._v("#")]),a._v(" 方法区存放哪些信息？")]),a._v(" "),t("p",[a._v("方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。")]),a._v(" "),t("h4",{attrs:{id:"方法区常用参数有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法区常用参数有哪些"}},[a._v("#")]),a._v(" 方法区常用参数有哪些？")]),a._v(" "),t("ul",[t("li",[t("code",[a._v("-XX:MetaspaceSize=N")]),a._v("：初始大小")]),a._v(" "),t("li",[t("code",[a._v("-XX:MaxMetaspaceSize")]),a._v("：最大大小")])]),a._v(" "),t("h4",{attrs:{id:"运行时常量池的作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#运行时常量池的作用"}},[a._v("#")]),a._v(" 运行时常量池的作用？")]),a._v(" "),t("p",[a._v("用于存放编译期生成的各种字面量和符号引用。"),t("br"),a._v("\n字面量：包括整数、浮点数、字符串字面量。"),t("br"),a._v("\n符号引用：类符号引用、字段符号引用、方法符号引用、接口符号引用。")]),a._v(" "),t("h4",{attrs:{id:"字符串常量池是什么-作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字符串常量池是什么-作用"}},[a._v("#")]),a._v(" 字符串常量池是什么？作用？")]),a._v(" "),t("p",[a._v("JVM 为了提高性能和减少内存消耗针对字符串专门开辟的一块区域。"),t("br"),a._v("\n作用：避免字符串的重复创建。")]),a._v(" "),t("h4",{attrs:{id:"字符串常量池中保存的是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字符串常量池中保存的是什么"}},[a._v("#")]),a._v(" 字符串常量池中保存的是什么？")]),a._v(" "),t("ul",[t("li",[a._v("字符串字面量")]),a._v(" "),t("li",[a._v("通过String类的intern()方法添加的字符串")]),a._v(" "),t("li",[a._v("编译器优化的字符串（比如将多个字符串合并为一个）")])]),a._v(" "),t("h4",{attrs:{id:"jdk1-7-为什么要将字符串常量池从永久代移动到堆中"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jdk1-7-为什么要将字符串常量池从永久代移动到堆中"}},[a._v("#")]),a._v(" JDK1.7 为什么要将字符串常量池从永久代移动到堆中？")]),a._v(" "),t("p",[a._v("永久代的GC回收效率太低，只有在Full GC的时候才会被执行GC，而程序中通常有大量被创建的字符串等待回收。")]),a._v(" "),t("h4",{attrs:{id:"直接内存和堆外内存是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#直接内存和堆外内存是什么"}},[a._v("#")]),a._v(" 直接内存和堆外内存是什么？")]),a._v(" "),t("p",[a._v("直接内存是一种特殊的内存缓冲区，通过Java NIO（New I/O）库中的 java.nio.ByteBuffer 来分配和管理的一种内存区域。它既不是虚拟机运行时数据区域的一部分，也不是虚拟机规范中定义的内存区域。"),t("br"),a._v("\n堆外内存是在 Java 堆之外分配的内存区域，包括直接内存和其他方式分配的内存。")]),a._v(" "),t("h4",{attrs:{id:"java-对象的创建过程是怎样的-重点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-对象的创建过程是怎样的-重点"}},[a._v("#")]),a._v(" Java 对象的创建过程是怎样的？（重点）")]),a._v(" "),t("p",[a._v("类加载检查 -> 分配内存 -> 初始化零值（数据类型对应的零值）-> 设置对象头（类、类元数据信息、哈希码、GC分代年龄等） -> 执行init方法")]),a._v(" "),t("h4",{attrs:{id:"内存分配有哪两种方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存分配有哪两种方式"}},[a._v("#")]),a._v(" 内存分配有哪两种方式？")]),a._v(" "),t("p",[a._v("指针碰撞、空闲列表")]),a._v(" "),t("h4",{attrs:{id:"内存分配并发有哪两种方式保证线程安全"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存分配并发有哪两种方式保证线程安全"}},[a._v("#")]),a._v(" 内存分配并发有哪两种方式保证线程安全？")]),a._v(" "),t("ul",[t("li",[a._v("CAS + 失败重试")]),a._v(" "),t("li",[a._v("TLAB：为每一个线程预先在 Eden 区分配一块内存，在给线程中的对象分配内存时首先在 TLAB 中分配，TLAB 不够分配时再采用 CAS 进行内存分配。")])]),a._v(" "),t("h4",{attrs:{id:"对象的内存布局是怎样的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象的内存布局是怎样的"}},[a._v("#")]),a._v(" 对象的内存布局是怎样的？")]),a._v(" "),t("p",[a._v("对象头、实例数据、对齐填充（仅起占位作用）")]),a._v(" "),t("h4",{attrs:{id:"对象的访问定位有哪几种方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象的访问定位有哪几种方式"}},[a._v("#")]),a._v(" 对象的访问定位有哪几种方式？")]),a._v(" "),t("p",[a._v("Java 程序通过栈上的 reference 数据来操作堆上的具体对象。")]),a._v(" "),t("ul",[t("li",[a._v("使用句柄：reference 存储对象句柄地址，句柄中存储 到对象实例数据的指针 和 到对象类型数据的指针。")]),a._v(" "),t("li",[a._v("直接指针：reference 直接存储对象的地址。")])]),a._v(" "),t("h2",{attrs:{id:"jvm-垃圾回收-gc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm-垃圾回收-gc"}},[a._v("#")]),a._v(" JVM 垃圾回收 GC")]),a._v(" "),t("h4",{attrs:{id:"java-自动内存管理指的是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-自动内存管理指的是什么"}},[a._v("#")]),a._v(" Java 自动内存管理指的是什么？")]),a._v(" "),t("p",[a._v("对象内存的分配与回收")]),a._v(" "),t("h4",{attrs:{id:"java-堆的基本结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-堆的基本结构"}},[a._v("#")]),a._v(" Java 堆的基本结构？")]),a._v(" "),t("p",[a._v("新生代、老年代、永久代/元空间")]),a._v(" "),t("h4",{attrs:{id:"内存分配和回收原则是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存分配和回收原则是什么"}},[a._v("#")]),a._v(" 内存分配和回收原则是什么？")]),a._v(" "),t("ul",[t("li",[a._v("对象优先在 Eden 区分配")]),a._v(" "),t("li",[a._v("大对象直接进行老年代")]),a._v(" "),t("li",[a._v("长期存活的对象将进入老年代")])]),a._v(" "),t("h4",{attrs:{id:"主要进行-gc-的区域是哪"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#主要进行-gc-的区域是哪"}},[a._v("#")]),a._v(" 主要进行 GC 的区域是哪？")]),a._v(" "),t("p",[a._v("根据 GC 策略：Partial GC：Minor/Young GC、Major/Old GC、Full GC")]),a._v(" "),t("h4",{attrs:{id:"空间分配担保是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#空间分配担保是什么"}},[a._v("#")]),a._v(" 空间分配担保是什么？")]),a._v(" "),t("h4",{attrs:{id:"死亡对象的判断方法有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#死亡对象的判断方法有哪些"}},[a._v("#")]),a._v(" 死亡对象的判断方法有哪些？")]),a._v(" "),t("p",[a._v("引用计数法、可达性分析法")]),a._v(" "),t("h4",{attrs:{id:"哪些对象可以作为-gc-roots"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#哪些对象可以作为-gc-roots"}},[a._v("#")]),a._v(" 哪些对象可以作为 GC Roots？")]),a._v(" "),t("h4",{attrs:{id:"对象可以被回收-就一定会被回收吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象可以被回收-就一定会被回收吗"}},[a._v("#")]),a._v(" 对象可以被回收，就一定会被回收吗？")]),a._v(" "),t("p",[a._v("标记、筛选、标记")]),a._v(" "),t("h4",{attrs:{id:"引用有哪几种类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引用有哪几种类型"}},[a._v("#")]),a._v(" 引用有哪几种类型？")]),a._v(" "),t("p",[a._v("强引用、软引用、弱引用、虚引用")]),a._v(" "),t("h4",{attrs:{id:"如何判断常量池中一个常量是废弃常量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何判断常量池中一个常量是废弃常量"}},[a._v("#")]),a._v(" 如何判断常量池中一个常量是废弃常量？")]),a._v(" "),t("p",[a._v("eg. 字符串常量池中没有任何对象引用该常量")]),a._v(" "),t("h4",{attrs:{id:"如何判断一个类是无用的类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何判断一个类是无用的类"}},[a._v("#")]),a._v(" 如何判断一个类是无用的类？")]),a._v(" "),t("p",[a._v("三个条件：实例、类加载器、Class 对象")]),a._v(" "),t("h4",{attrs:{id:"垃圾收集的算法有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集的算法有哪些"}},[a._v("#")]),a._v(" 垃圾收集的算法有哪些？")]),a._v(" "),t("p",[a._v("标记-清除、标记-复制、标记-整理、分代收集")]),a._v(" "),t("h4",{attrs:{id:"hotspot-为什么要分为新生代和老年代"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hotspot-为什么要分为新生代和老年代"}},[a._v("#")]),a._v(" Hotspot 为什么要分为新生代和老年代？")]),a._v(" "),t("p",[a._v("对象存活周期不同"),t("br"),a._v("\n新生代：标记-复制\n老年代：标记-清除/整理")]),a._v(" "),t("h4",{attrs:{id:"什么是垃圾收集器-有哪些垃圾收集器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是垃圾收集器-有哪些垃圾收集器"}},[a._v("#")]),a._v(" 什么是垃圾收集器？有哪些垃圾收集器？")]),a._v(" "),t("ul",[t("li",[a._v("Serial")]),a._v(" "),t("li",[a._v("ParNew")]),a._v(" "),t("li",[a._v("Parallel Scavenge")]),a._v(" "),t("li",[a._v("Serial Old")]),a._v(" "),t("li",[a._v("Parallel Old")]),a._v(" "),t("li",[a._v("CMS（重点收集器）")]),a._v(" "),t("li",[a._v("G1（重点收集器）")]),a._v(" "),t("li",[a._v("ZGC")])]),a._v(" "),t("h2",{attrs:{id:"类文件结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类文件结构"}},[a._v("#")]),a._v(" 类文件结构")]),a._v(" "),t("ul",[t("li",[a._v("魔数")]),a._v(" "),t("li",[a._v("Class 文件版本号")]),a._v(" "),t("li",[a._v("常量池")]),a._v(" "),t("li",[a._v("访问标志")]),a._v(" "),t("li",[a._v("（当前类、父类、接口）索引集合")]),a._v(" "),t("li",[a._v("字段表集合")]),a._v(" "),t("li",[a._v("方法表集合")]),a._v(" "),t("li",[a._v("属性表集合")])]),a._v(" "),t("h2",{attrs:{id:"类加载过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类加载过程"}},[a._v("#")]),a._v(" 类加载过程")]),a._v(" "),t("h4",{attrs:{id:"类的生命周期各个阶段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类的生命周期各个阶段"}},[a._v("#")]),a._v(" 类的生命周期各个阶段？")]),a._v(" "),t("ul",[t("li",[a._v("加载：类加载器加载")]),a._v(" "),t("li",[a._v("连接：分为验证、准备、解析三个阶段")]),a._v(" "),t("li",[a._v("初始化")]),a._v(" "),t("li",[a._v("使用")]),a._v(" "),t("li",[a._v("卸载（Class 对象被 GC）")])]),a._v(" "),t("h4",{attrs:{id:"系统加载-class-文件的步骤"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#系统加载-class-文件的步骤"}},[a._v("#")]),a._v(" 系统加载 Class 文件的步骤？")]),a._v(" "),t("p",[a._v("加载 -> 连接 -> 初始化"),t("br"),a._v("\n连接：验证（是否合法）-> 准备（方法区分配空间、设置零值）-> 解析（符号引用转为直接引用）")]),a._v(" "),t("h2",{attrs:{id:"类加载器详解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类加载器详解"}},[a._v("#")]),a._v(" 类加载器详解")]),a._v(" "),t("h4",{attrs:{id:"加载所做的事有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#加载所做的事有哪些"}},[a._v("#")]),a._v(" 加载所做的事有哪些？")]),a._v(" "),t("ul",[t("li",[a._v("获取类的二进制字节流")]),a._v(" "),t("li",[a._v("将字节流代表的静态存储结构转换为方法区的运行时数据结构")]),a._v(" "),t("li",[a._v("生成 Class 对象，作为方法区数据访问入口")])]),a._v(" "),t("h4",{attrs:{id:"类加载器加载规则是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类加载器加载规则是什么"}},[a._v("#")]),a._v(" 类加载器加载规则是什么？")]),a._v(" "),t("ul",[t("li",[a._v("根据需要动态加载")]),a._v(" "),t("li",[a._v("相同二进制名称的类只会被加载一次")])]),a._v(" "),t("h4",{attrs:{id:"jvm-内置的三个重要的-classloader"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm-内置的三个重要的-classloader"}},[a._v("#")]),a._v(" JVM 内置的三个重要的 ClassLoader？")]),a._v(" "),t("ul",[t("li",[a._v("BootstrapClassLoader（启动类加载器）")]),a._v(" "),t("li",[a._v("ExtensionClassLoader（扩展类加载器）")]),a._v(" "),t("li",[a._v("AppClassLoader（应用程序类加载器）")])]),a._v(" "),t("h4",{attrs:{id:"获取到-classloader-为-null-为什么就是-bootstrapclassloader-加载的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#获取到-classloader-为-null-为什么就是-bootstrapclassloader-加载的"}},[a._v("#")]),a._v(" 获取到 ClassLoader 为 null 为什么就是 BootstrapClassLoader 加载的？")]),a._v(" "),t("p",[a._v("BootstrapClassLoader 是由 C++ 实现的")]),a._v(" "),t("h4",{attrs:{id:"自定义类加载器要怎么做"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自定义类加载器要怎么做"}},[a._v("#")]),a._v(" 自定义类加载器要怎么做？")]),a._v(" "),t("p",[a._v("继承 Java.lang.ClassLoader 抽象类，并重写两个重要方法之一：\n"),t("code",[a._v("loadClass()")]),a._v("：会打破双亲委派模型\n"),t("code",[a._v("findClass()")]),a._v("：不会打破双亲委派模型，建议使用这个")]),a._v(" "),t("h4",{attrs:{id:"类的双亲委派模型是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类的双亲委派模型是什么"}},[a._v("#")]),a._v(" 类的双亲委派模型是什么？")]),a._v(" "),t("p",[a._v("各种类加载器之间的层次关系")]),a._v(" "),t("h4",{attrs:{id:"类加载器之间的父子关系是怎么实现的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类加载器之间的父子关系是怎么实现的"}},[a._v("#")]),a._v(" 类加载器之间的父子关系是怎么实现的？")]),a._v(" "),t("p",[a._v("不是通过继承实现的，而是通过组合实现的，在类中引用父加载器的实例来复用父加载器代码。")]),a._v(" "),t("h4",{attrs:{id:"双亲委派模型的执行流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派模型的执行流程"}},[a._v("#")]),a._v(" 双亲委派模型的执行流程？")]),a._v(" "),t("ol",[t("li",[a._v("检查当前类是否已加载（每个父加载器都查一遍）")]),a._v(" "),t("li",[a._v("委派给父加载器去加载("),t("code",[a._v("loadClass()")]),a._v(")，父加载器无法完成，子加载器才会自己去尝试加载("),t("code",[a._v("findClass()")]),a._v(")")]),a._v(" "),t("li",[a._v("如果子加载器也无法加载，抛出 "),t("code",[a._v("ClassNotFoundException")])])]),a._v(" "),t("h4",{attrs:{id:"jvm-判定两个-java-类是否相同的具体规则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm-判定两个-java-类是否相同的具体规则"}},[a._v("#")]),a._v(" JVM 判定两个 Java 类是否相同的具体规则？")]),a._v(" "),t("ul",[t("li",[a._v("类的全名")]),a._v(" "),t("li",[a._v("类加载器")])]),a._v(" "),t("h4",{attrs:{id:"为什么-spi-需要自定义类加载器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么-spi-需要自定义类加载器"}},[a._v("#")]),a._v(" 为什么 SPI 需要自定义类加载器？")]),a._v(" "),t("p",[a._v("SPI 由核心库提供，实现是由第三方提供的。"),t("br"),a._v("\n本来应该由 SPI 接口的加载器（BootstrapClassLoader）加载实现类，但它是找不到的。")]),a._v(" "),t("h4",{attrs:{id:"什么是线程上下文类加载器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是线程上下文类加载器"}},[a._v("#")]),a._v(" 什么是线程上下文类加载器？")]),a._v(" "),t("p",[a._v("将一个类加载器保存在线程私有数据与线程绑定，需要时取出使用 ContextClassLoader。"),t("br"),a._v("\n如果没有设置，继承父线程的上下文类加载器。")])])}),[],!1,null,null,null);v.default=r.exports}}]);